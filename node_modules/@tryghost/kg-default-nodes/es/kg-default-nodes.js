import { DecoratorNode, createCommand } from 'lexical';
import cleanBasicHtml from '@tryghost/kg-clean-basic-html';
import markdownHtmlRenderer from '@tryghost/kg-markdown-html-renderer';

class KoenigDecoratorNode extends DecoratorNode {}
function $isKoenigCard(node) {
  return node instanceof KoenigDecoratorNode;
}

function readImageAttributesFromNode(node) {
  const attrs = {};
  if (node.src) {
    attrs.src = node.src;
  }
  if (node.width) {
    attrs.width = node.width;
  } else if (node.dataset && node.dataset.width) {
    attrs.width = parseInt(node.dataset.width, 10);
  }
  if (node.height) {
    attrs.height = node.height;
  } else if (node.dataset && node.dataset.height) {
    attrs.height = parseInt(node.dataset.height, 10);
  }
  if (!node.width && !node.height && node.getAttribute('data-image-dimensions')) {
    const [, width, height] = /^(\d*)x(\d*)$/gi.exec(node.getAttribute('data-image-dimensions'));
    attrs.width = parseInt(width, 10);
    attrs.height = parseInt(height, 10);
  }
  if (node.alt) {
    attrs.alt = node.alt;
  }
  if (node.title) {
    attrs.title = node.title;
  }
  if (node.parentNode.tagName === 'A') {
    const href = node.parentNode.href;
    if (href !== attrs.src) {
      attrs.href = href;
    }
  }
  return attrs;
}
function addFigCaptionToPayload(node, payload, _ref) {
  let {
    selector = 'figcaption',
    options
  } = _ref;
  let figcaptions = Array.from(node.querySelectorAll(selector));
  if (figcaptions.length) {
    figcaptions.forEach(caption => {
      let cleanHtml = options?.cleanBasicHtml ? options.cleanBasicHtml(caption.innerHTML) : caption.innerHTML;
      payload.caption = payload.caption ? `${payload.caption} / ${cleanHtml}` : cleanHtml;
      caption.remove(); // cleanup this processed element
    });
  }
}

class ImageParser {
  constructor(NodeClass) {
    this.NodeClass = NodeClass;
  }
  get DOMConversionMap() {
    const self = this;
    return {
      img: () => ({
        conversion(domNode) {
          if (domNode.tagName === 'IMG') {
            const {
              src,
              width,
              height,
              alt: altText,
              title
            } = readImageAttributesFromNode(domNode);
            const node = new self.NodeClass({
              altText,
              src,
              title,
              width,
              height
            });
            return {
              node
            };
          }
          return null;
        },
        priority: 1
      }),
      figure: nodeElem => {
        if (!nodeElem.querySelector('img')) {
          return null;
        }
        return {
          conversion(domNode) {
            const img = domNode.querySelector('img');
            const kgClass = domNode.className.match(/kg-width-(wide|full)/);
            const grafClass = domNode.className.match(/graf--layout(FillWidth|OutsetCenter)/);
            if (!img) {
              return null;
            }
            const payload = readImageAttributesFromNode(img);
            if (kgClass) {
              payload.cardWidth = kgClass[1];
            } else if (grafClass) {
              payload.cardWidth = grafClass[1] === 'FillWidth' ? 'full' : 'wide';
            }
            const options = {
              cleanBasicHtml: html => {
                const cleanedHtml = cleanBasicHtml(html, {
                  createDocument: _html => {
                    const newDoc = domNode.ownerDocument.implementation.createHTMLDocument();
                    newDoc.body.innerHTML = _html;
                    return newDoc;
                  }
                });
                return cleanedHtml;
              }
            };
            addFigCaptionToPayload(domNode, payload, {
              options
            });
            const {
              src,
              width,
              height,
              alt: altText,
              title,
              caption,
              cardWidth,
              href
            } = payload;
            const node = new self.NodeClass({
              altText,
              src,
              title,
              width,
              height,
              caption,
              cardWidth,
              href
            });
            return {
              node
            };
          },
          priority: 1
        };
      }
    };
  }
}

const getAvailableImageWidths = function (image, imageSizes) {
  // get a sorted list of the available responsive widths
  const imageWidths = Object.values(imageSizes).map(_ref => {
    let {
      width
    } = _ref;
    return width;
  }).sort((a, b) => a - b);

  // select responsive widths that are usable based on the image width
  const availableImageWidths = imageWidths.filter(width => width <= image.width);

  // add the original image size to the responsive list if it's not captured by largest responsive size
  // - we can't know the width/height of the original `src` image because we don't know if it was resized
  //   or not. Adding the original image to the responsive list ensures we're not showing smaller sized
  //   images than we need to be
  if (image.width > availableImageWidths[availableImageWidths.length - 1] && image.width < imageWidths[imageWidths.length - 1]) {
    availableImageWidths.push(image.width);
  }
  return availableImageWidths;
};

const isLocalContentImage = function (url) {
  let siteUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  const normalizedSiteUrl = siteUrl.replace(/\/$/, '');
  const imagePath = url.replace(normalizedSiteUrl, '');
  return /^(\/.*|__GHOST_URL__)\/?content\/images\//.test(imagePath);
};

const isUnsplashImage = function (url) {
  return /images\.unsplash\.com/.test(url);
};

// default content sizes: [600, 1000, 1600, 2400]

const getSrcsetAttribute = function (_ref) {
  let {
    src,
    width,
    options
  } = _ref;
  if (!options.imageOptimization || options.imageOptimization.srcsets === false || !width || !options.imageOptimization.contentImageSizes) {
    return;
  }
  if (isLocalContentImage(src, options.siteUrl) && options.canTransformImage && !options.canTransformImage(src)) {
    return;
  }
  const srcsetWidths = getAvailableImageWidths({
    width
  }, options.imageOptimization.contentImageSizes);

  // apply srcset if this is a relative image that matches Ghost's image url structure
  if (isLocalContentImage(src, options.siteUrl)) {
    const [, imagesPath, filename] = src.match(/(.*\/content\/images)\/(.*)/);
    const srcs = [];
    srcsetWidths.forEach(srcsetWidth => {
      if (srcsetWidth === width) {
        // use original image path if width matches exactly (avoids 302s from size->original)
        srcs.push(`${src} ${srcsetWidth}w`);
      } else if (srcsetWidth <= width) {
        // avoid creating srcset sizes larger than intrinsic image width
        srcs.push(`${imagesPath}/size/w${srcsetWidth}/${filename} ${srcsetWidth}w`);
      }
    });
    if (srcs.length) {
      return srcs.join(', ');
    }
  }

  // apply srcset if this is an Unsplash image
  if (isUnsplashImage(src)) {
    const unsplashUrl = new URL(src);
    const srcs = [];
    srcsetWidths.forEach(srcsetWidth => {
      unsplashUrl.searchParams.set('w', srcsetWidth);
      srcs.push(`${unsplashUrl.href} ${srcsetWidth}w`);
    });
    return srcs.join(', ');
  }
};
const setSrcsetAttribute = function (elem, image, options) {
  if (!elem || !['IMG', 'SOURCE'].includes(elem.tagName) || !elem.getAttribute('src') || !image) {
    return;
  }
  const {
    src,
    width
  } = image;
  const srcset = getSrcsetAttribute({
    src,
    width,
    options
  });
  if (srcset) {
    elem.setAttribute('srcset', srcset);
  }
};

const resizeImage = function (image) {
  let {
    width: desiredWidth,
    height: desiredHeight
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    width,
    height
  } = image;
  const ratio = width / height;
  if (desiredWidth) {
    const resizedHeight = Math.round(desiredWidth / ratio);
    return {
      width: desiredWidth,
      height: resizedHeight
    };
  }
  if (desiredHeight) {
    const resizedWidth = Math.round(desiredHeight * ratio);
    return {
      width: resizedWidth,
      height: desiredHeight
    };
  }
};

function renderImageNodeToDOM(node) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  /* c8 ignore start */
  if (!options.createDocument) {
    let document = typeof window !== 'undefined' && window.document;
    if (!document) {
      throw new Error('renderImageNodeToDOM() must be passed a `createDocument` function as an option when used in a non-browser environment'); // eslint-disable-line
    }

    options.createDocument = function () {
      return document;
    };
  }
  /* c8 ignore stop */

  const document = options.createDocument();
  if (!node.getSrc() || node.getSrc().trim() === '') {
    return document.createTextNode('');
  }
  const figure = document.createElement('figure');
  let figureClasses = 'kg-card kg-image-card';
  if (node.getCardWidth() !== 'regular') {
    figureClasses += ` kg-width-${node.getCardWidth()}`;
  }
  figure.setAttribute('class', figureClasses);
  const img = document.createElement('img');
  img.setAttribute('src', node.getSrc());
  img.setAttribute('alt', node.getAltText());
  img.setAttribute('loading', 'lazy');
  if (node.getTitle()) {
    img.setAttribute('title', node.getTitle());
  }
  if (node.getImgWidth() && node.getImgHeight()) {
    img.setAttribute('width', node.getImgWidth());
    img.setAttribute('height', node.getImgHeight());
  }

  // images can be resized to max width, if that's the case output
  // the resized width/height attrs to ensure 3rd party gallery plugins
  // aren't affected by differing sizes
  const {
    canTransformImage
  } = options;
  const {
    defaultMaxWidth
  } = options.imageOptimization || {};
  if (defaultMaxWidth && node.getImgWidth() > defaultMaxWidth && isLocalContentImage(node.getSrc(), options.siteUrl) && canTransformImage && canTransformImage(node.getSrc())) {
    const imageDimensions = {
      width: node.getImgWidth(),
      height: node.getImgHeight()
    };
    const {
      width,
      height
    } = resizeImage(imageDimensions, {
      width: defaultMaxWidth
    });
    img.setAttribute('width', width);
    img.setAttribute('height', height);
  }
  if (options.target !== 'email') {
    const imgAttributes = {
      src: node.getSrc(),
      width: node.getImgWidth(),
      height: node.getImgHeight()
    };
    setSrcsetAttribute(img, imgAttributes, options);
    if (img.getAttribute('srcset') && node.getImgWidth() && node.getImgWidth() >= 720) {
      // standard size
      if (!node.getCardWidth() || node.getCardWidth() === 'regular') {
        img.setAttribute('sizes', '(min-width: 720px) 720px');
      }
      if (node.getCardWidth() === 'wide' && node.getImgWidth() >= 1200) {
        img.setAttribute('sizes', '(min-width: 1200px) 1200px');
      }
    }
  }

  // Outlook is unable to properly resize images without a width/height
  // so we add that at the expected size in emails (600px) and use a higher
  // resolution image to keep images looking good on retina screens
  if (options.target === 'email' && node.getImgWidth() && node.getImgHeight()) {
    let imageDimensions = {
      width: node.getImgWidth(),
      height: node.getImgHeight()
    };
    if (node.getImgWidth() >= 600) {
      imageDimensions = resizeImage(imageDimensions, {
        width: 600
      });
    }
    img.setAttribute('width', imageDimensions.width);
    img.setAttribute('height', imageDimensions.height);
    if (isLocalContentImage(node.getSrc(), options.siteUrl) && options.canTransformImage?.(node.getSrc())) {
      // find available image size next up from 2x600 so we can use it for the "retina" src
      const availableImageWidths = getAvailableImageWidths(node, options.imageOptimization.contentImageSizes);
      const srcWidth = availableImageWidths.find(width => width >= 1200);
      if (!srcWidth || srcWidth === node.getImgWidth()) ; else {
        const [, imagesPath, filename] = node.getSrc().match(/(.*\/content\/images)\/(.*)/);
        img.setAttribute('src', `${imagesPath}/size/w${srcWidth}/${filename}`);
      }
    }
  }
  if (node.getHref()) {
    const a = document.createElement('a');
    a.setAttribute('href', node.getHref());
    a.appendChild(img);
    figure.appendChild(a);
  } else {
    figure.appendChild(img);
  }
  if (node.getCaption()) {
    const caption = document.createElement('figcaption');
    caption.innerHTML = node.getCaption();
    figure.appendChild(caption);
  }
  return figure;
}

const INSERT_IMAGE_COMMAND = createCommand();
const UPLOAD_IMAGE_COMMAND = createCommand();
class ImageNode extends KoenigDecoratorNode {
  // payload properties
  __src;
  __caption;
  __title;
  __altText;
  __cardWidth;
  __width;
  __height;
  __href;
  static getType() {
    return 'image';
  }
  static clone(node) {
    return new this(node.getDataset(), node.__key);
  }

  // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
  static get urlTransformMap() {
    return {
      src: 'url',
      href: 'url',
      caption: 'html'
    };
  }
  getDataset() {
    const self = this.getLatest();
    return {
      src: self.__src,
      caption: self.__caption,
      title: self.__title,
      altText: self.__altText,
      width: self.__width,
      height: self.__height,
      cardWidth: self.__cardWidth,
      href: self.__href
    };
  }
  constructor() {
    let {
      src,
      caption,
      title,
      altText,
      cardWidth,
      width,
      height,
      href
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    super(key);
    this.__src = src || '';
    this.__title = title || '';
    this.__caption = caption || '';
    this.__altText = altText || '';
    this.__width = width || null;
    this.__height = height || null;
    this.__cardWidth = cardWidth || 'regular';
    this.__href = href || '';
  }
  static importJSON(serializedNode) {
    const {
      src,
      caption,
      title,
      altText,
      width,
      height,
      cardWidth,
      href
    } = serializedNode;
    const node = new this({
      src,
      caption,
      title,
      altText,
      width,
      height,
      href,
      cardWidth
    });
    return node;
  }
  exportJSON() {
    // checks if src is a data string
    const src = this.getSrc();
    const isBlob = src.startsWith('data:');
    const dataset = {
      type: 'image',
      version: 1,
      src: isBlob ? '<base64String>' : this.getSrc(),
      width: this.getImgWidth(),
      height: this.getImgHeight(),
      title: this.getTitle(),
      altText: this.getAltText(),
      caption: this.getCaption(),
      cardWidth: this.getCardWidth(),
      href: this.getHref()
    };
    return dataset;
  }
  static importDOM() {
    const parser = new ImageParser(this);
    return parser.DOMConversionMap;
  }
  exportDOM() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const element = renderImageNodeToDOM(this, options);
    return {
      element
    };
  }

  /* c8 ignore start */
  createDOM() {
    const element = document.createElement('div');
    return element;
  }
  updateDOM() {
    return false;
  }
  isInline() {
    return false;
  }
  /* c8 ignore stop */

  getSrc() {
    const self = this.getLatest();
    return self.__src;
  }
  setSrc(src) {
    const writable = this.getWritable();
    return writable.__src = src;
  }
  getTitle() {
    const self = this.getLatest();
    return self.__title;
  }
  setTitle(title) {
    const writable = this.getWritable();
    return writable.__title = title;
  }
  getHref() {
    const self = this.getLatest();
    return self.__href;
  }
  setHref(href) {
    const writable = this.getWritable();
    return writable.__href = href;
  }
  setCardWidth(cardWidth) {
    const writable = this.getWritable();
    return writable.__cardWidth = cardWidth;
  }
  getCardWidth() {
    const self = this.getLatest();
    return self.__cardWidth;
  }
  getImgWidth() {
    const self = this.getLatest();
    return self.__width;
  }
  setImgWidth(width) {
    const writable = this.getWritable();
    return writable.__width = width;
  }
  getImgHeight() {
    const self = this.getLatest();
    return self.__height;
  }
  setImgHeight(height) {
    const writable = this.getWritable();
    return writable.__height = height;
  }
  getCaption() {
    const self = this.getLatest();
    return self.__caption;
  }
  setCaption(caption) {
    const writable = this.getWritable();
    return writable.__caption = caption;
  }
  getAltText() {
    const self = this.getLatest();
    return self.__altText;
  }
  setAltText(altText) {
    const writable = this.getWritable();
    return writable.__altText = altText;
  }

  // should be overridden
  /* c8 ignore next 3 */
  decorate() {
    return '';
  }
}
const $createImageNode = dataset => {
  return new ImageNode(dataset);
};
function $isImageNode(node) {
  return node instanceof ImageNode;
}

class CodeBlockParser {
  constructor(NodeClass) {
    this.NodeClass = NodeClass;
  }
  get DOMConversionMap() {
    const self = this;
    return {
      figure: () => ({
        conversion(domNode) {
          if (domNode.tagName === 'FIGURE') {
            const pre = domNode.querySelector('pre');

            // If this figure doesn't have a pre tag in it
            if (!pre) {
              return null;
            }
            let code = pre.querySelector('code');
            let figcaption = domNode.querySelector('figcaption');

            // if there's no caption the pre key should pick it up
            if (!code || !figcaption) {
              return null;
            }
            let payload = {
              code: code.textContent
            };
            let figcaptions = Array.from(domNode.querySelectorAll('figcaption'));
            if (figcaptions.length) {
              figcaptions.forEach(caption => {
                //TODO: use cleanBasicHtml here
                // let cleanHtml = cleanBasicHtml(caption.innerHTML);
                let cleanHtml = caption.innerHTML;
                payload.caption = payload.caption ? `${payload.caption} / ${cleanHtml}` : cleanHtml;
                caption.remove(); // cleanup this processed element
              });
            }

            let preClass = pre.getAttribute('class') || '';
            let codeClass = code.getAttribute('class') || '';
            let langRegex = /lang(?:uage)?-(.*?)(?:\s|$)/i;
            let languageMatches = preClass.match(langRegex) || codeClass.match(langRegex);
            if (languageMatches) {
              payload.language = languageMatches[1].toLowerCase();
            }
            const node = new self.NodeClass(payload);
            return {
              node
            };
          }
          return null;
        },
        priority: 1
      }),
      pre: () => ({
        conversion(domNode) {
          if (domNode.tagName === 'PRE') {
            let [codeElement] = domNode.children;
            if (codeElement && codeElement.tagName === 'CODE') {
              let payload = {
                code: codeElement.textContent
              };
              let preClass = domNode.getAttribute('class') || '';
              let codeClass = codeElement.getAttribute('class') || '';
              let langRegex = /lang(?:uage)?-(.*?)(?:\s|$)/i;
              let languageMatches = preClass.match(langRegex) || codeClass.match(langRegex);
              if (languageMatches) {
                payload.language = languageMatches[1].toLowerCase();
              }
              const node = new self.NodeClass(payload);
              return {
                node
              };
            }
          }
          return null;
        },
        priority: 1
      })
    };
  }
}

function renderCodeBlockNodeToDOM(node) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  /* c8 ignore start */
  if (!options.createDocument) {
    let document = typeof window !== 'undefined' && window.document;
    if (!document) {
      throw new Error('renderImageNodeToDOM() must be passed a `createDocument` function as an option when used in a non-browser environment'); // eslint-disable-line
    }

    options.createDocument = function () {
      return document;
    };
  }
  /* c8 ignore stop */

  const document = options.createDocument();
  if (!node.getCode() || node.getCode().trim() === '') {
    return document.createTextNode('');
  }
  const pre = document.createElement('pre');
  const code = document.createElement('code');
  if (node.getLanguage()) {
    code.setAttribute('class', `language-${node.getLanguage()}`);
  }
  code.appendChild(document.createTextNode(node.getCode()));
  pre.appendChild(code);
  if (node.getCaption()) {
    let figure = document.createElement('figure');
    figure.setAttribute('class', 'kg-card kg-code-card');
    figure.appendChild(pre);
    let figcaption = document.createElement('figcaption');
    figcaption.appendChild(document.createTextNode(node.getCaption()));
    figure.appendChild(figcaption);
    return figure;
  } else {
    return pre;
  }
}

const INSERT_CODE_BLOCK_COMMAND = createCommand();
class CodeBlockNode extends KoenigDecoratorNode {
  __code;
  __language;
  __caption;
  static getType() {
    return 'codeblock';
  }
  static clone(node) {
    // must use `this` so the extended class in the Editor uses the correct class when cloning
    // without needing to override this method
    return new this(node.getDataset(), node.__key);
  }

  // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
  static get urlTransformMap() {
    return {
      caption: 'html'
    };
  }
  getDataset() {
    const self = this.getLatest();
    return {
      code: self.__code,
      language: self.__language,
      caption: self.__caption
    };
  }
  static importJSON(serializedNode) {
    const {
      code,
      language,
      caption
    } = serializedNode;
    const node = new this({
      code,
      language,
      caption
    });
    return node;
  }
  exportJSON() {
    return {
      type: 'codeblock',
      version: 1,
      code: this.__code,
      language: this.__language,
      caption: this.__caption
    };
  }
  constructor() {
    let {
      code,
      language,
      caption
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    super(key);
    this.__code = code;
    this.__language = language;
    this.__caption = caption;
  }
  static importDOM() {
    const parser = new CodeBlockParser(this);
    return parser.DOMConversionMap;
  }
  exportDOM() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const element = renderCodeBlockNodeToDOM(this, options);
    return {
      element
    };
  }

  /* c8 ignore start */
  createDOM() {
    return document.createElement('div');
  }
  updateDOM() {
    return false;
  }
  isInline() {
    return false;
  }
  /* c8 ignore stop */

  getCaption() {
    const self = this.getLatest();
    return self.__caption;
  }
  setCaption(caption) {
    const self = this.getWritable();
    self.__caption = caption;
  }
  getCode() {
    const self = this.getLatest();
    return self.__code;
  }
  setCode(code) {
    const self = this.getWritable();
    self.__code = code;
  }
  getLanguage() {
    const self = this.getLatest();
    return self.__language;
  }
  setLanguage(language) {
    const self = this.getWritable();
    self.__language = language;
  }
  getTextContent() {
    const self = this.getLatest();
    return self.__code;
  }

  // should be overwritten
  /* c8 ignore next 3 */
  decorate() {
    return '';
  }
  hasEditMode() {
    return true;
  }
  isEmpty() {
    return !this.__code;
  }
}
function $createCodeBlockNode(dataset) {
  return new CodeBlockNode(dataset);
}
function $isCodeBlockNode(node) {
  return node instanceof CodeBlockNode;
}

function renderMarkdownNodeToDOM(node) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  /* c8 ignore start */
  if (!options.createDocument) {
    let document = typeof window !== 'undefined' && window.document;
    if (!document) {
      throw new Error('renderMarkdownNodeToDOM() must be passed a `createDocument` function as an option when used in a non-browser environment'); // eslint-disable-line
    }

    options.createDocument = function () {
      return document;
    };
  }
  /* c8 ignore stop */

  const document = options.createDocument();
  const html = markdownHtmlRenderer.render(node.getMarkdown() || '', options);
  const div = document.createElement('div');
  div.innerHTML = html;
  return div;
}

const INSERT_MARKDOWN_COMMAND = createCommand();
class MarkdownNode extends KoenigDecoratorNode {
  __markdown;
  static getType() {
    return 'markdown';
  }
  static clone(node) {
    return new this(node.getDataset(), node.__key);
  }

  // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
  static get urlTransformMap() {
    return {
      markdown: 'markdown'
    };
  }
  getDataset() {
    const self = this.getLatest();
    return {
      markdown: self.__markdown
    };
  }
  static importJSON(serializedNode) {
    const {
      markdown
    } = serializedNode;
    const node = new this({
      markdown
    });
    return node;
  }
  exportJSON() {
    return {
      type: 'markdown',
      version: 1,
      markdown: this.getMarkdown()
    };
  }
  constructor() {
    let {
      markdown
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    super(key);
    this.__markdown = markdown;
  }
  exportDOM() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const element = renderMarkdownNodeToDOM(this, options);
    return {
      element,
      type: 'inner'
    };
  }

  /* c8 ignore start */
  createDOM() {
    const element = document.createElement('div');
    return element;
  }
  updateDOM() {
    return false;
  }
  isInline() {
    return false;
  }
  /* c8 ignore stop */

  getMarkdown() {
    return this.__markdown;
  }
  setMarkdown(markdown) {
    const writable = this.getWritable();
    return writable.__markdown = markdown;
  }

  // should be overwritten
  /* c8 ignore next 3 */
  decorate() {
    return '';
  }
  hasEditMode() {
    return true;
  }
  isEmpty() {
    return !this.__markdown;
  }
}
function $createMarkdownNode(dataset) {
  return new MarkdownNode(dataset);
}
function $isMarkdownNode(node) {
  return node instanceof MarkdownNode;
}

class VideoParser {
  constructor(NodeClass) {
    this.NodeClass = NodeClass;
  }
  get DOMConversionMap() {
    const self = this;
    return {
      figure: () => ({
        conversion(domNode) {
          const isKgVideoCard = domNode.classList?.contains('kg-video-card');
          if (domNode.tagName === 'FIGURE' && isKgVideoCard) {
            const videoNode = domNode.querySelector('.kg-video-container video');
            const durationNode = domNode.querySelector('.kg-video-duration');
            const videoSrc = videoNode && videoNode.src;
            const videoWidth = videoNode && videoNode.width;
            const videoHeight = videoNode && videoNode.height;
            const durationText = durationNode && durationNode.innerHTML.trim();
            const captionNode = domNode.querySelector('figcaption');
            const captionText = captionNode && captionNode.innerHTML.trim();
            if (!videoSrc) {
              return null;
            }
            const payload = {
              src: videoSrc,
              loop: !!videoNode.loop,
              cardWidth: getCardWidth(videoNode)
            };
            if (durationText) {
              const [minutes, seconds] = durationText.split(':');
              try {
                payload.duration = parseInt(minutes) * 60 + parseInt(seconds);
              } catch (e) {
                // ignore duration
              }
            }
            if (domNode.dataset.kgThumbnail) {
              payload.thumbnailSrc = domNode.dataset.kgThumbnail;
            }
            if (domNode.dataset.kgCustomThumbnail) {
              payload.customThumbnailSrc = domNode.dataset.kgCustomThumbnail;
            }
            if (captionText) {
              payload.caption = captionText;
            }
            if (videoWidth) {
              payload.width = videoWidth;
            }
            if (videoHeight) {
              payload.height = videoHeight;
            }
            const node = new self.NodeClass(payload);
            return {
              node
            };
          }
          return null;
        },
        priority: 1
      })
    };
  }
}
function getCardWidth(domNode) {
  if (domNode.classList.contains('kg-width-full')) {
    return 'full';
  } else if (domNode.classList.contains('kg-width-wide')) {
    return 'wide';
  } else {
    return 'regular';
  }
}

function renderVideoNodeToDOM(node) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  /* c8 ignore start */
  if (!options.createDocument) {
    let document = typeof window !== 'undefined' && window.document;
    if (!document) {
      throw new Error('renderVideoNodeToDOM() must be passed a `createDocument` function as an option when used in a non-browser environment'); // eslint-disable-line
    }

    options.createDocument = function () {
      return document;
    };
  }
  /* c8 ignore stop */

  const document = options.createDocument();
  if (!node.getSrc() || node.getSrc().trim() === '') {
    return document.createTextNode('');
  }
  const cardClasses = getCardClasses(node).join(' ');
  const htmlString = options.target === 'email' ? emailCardTemplate({
    node,
    options,
    cardClasses
  }) : cardTemplate({
    node,
    cardClasses
  });
  const element = document.createElement('div');
  element.innerHTML = htmlString.trim();
  return element.firstElementChild;
}
function cardTemplate(_ref) {
  let {
    node,
    cardClasses
  } = _ref;
  const width = node.getVideoWidth();
  const height = node.getVideoHeight();
  const posterSpacerSrc = `https://img.spacergif.org/v1/${width}x${height}/0a/spacer.png`;
  const autoplayAttr = node.getLoop() ? 'loop autoplay muted' : '';
  const thumbnailSrc = node.getCustomThumbnailSrc() || node.getThumbnailSrc();
  const hideControlsClass = node.getLoop() ? ' kg-video-hide' : '';
  return `
        <figure class="${cardClasses}" data-kg-thumbnail=${node.getThumbnailSrc()} data-kg-custom-thumbnail=${node.getCustomThumbnailSrc()}>
            <div class="kg-video-container">
                <video
                    src="${node.getSrc()}"
                    poster="${posterSpacerSrc}"
                    width="${width}"
                    height="${height}"
                    ${autoplayAttr}
                    playsinline
                    preload="metadata"
                    style="background: transparent url('${thumbnailSrc}') 50% 50% / cover no-repeat;"
                ></video>
                <div class="kg-video-overlay">
                    <button class="kg-video-large-play-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z"/>
                        </svg>
                    </button>
                </div>
                <div class="kg-video-player-container${hideControlsClass}">
                    <div class="kg-video-player">
                        <button class="kg-video-play-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z"></path>
                            </svg>
                        </button>
                        <button class="kg-video-pause-icon kg-video-hide">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <rect x="3" y="1" width="7" height="22" rx="1.5" ry="1.5"></rect>
                                <rect x="14" y="1" width="7" height="22" rx="1.5" ry="1.5"></rect>
                            </svg>
                        </button>
                        <span class="kg-video-current-time">0:00</span>
                        <div class="kg-video-time">
                            /<span class="kg-video-duration">${node.getFormattedDuration()}</span>
                        </div>
                        <input type="range" class="kg-video-seek-slider" max="100" value="0">
                        <button class="kg-video-playback-rate">1&#215;</button>
                        <button class="kg-video-unmute-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M15.189 2.021a9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1.794a.249.249 0 0 1 .221.133 9.73 9.73 0 0 0 7.924 4.85h.06a1 1 0 0 0 1-1V3.02a1 1 0 0 0-1.06-.998Z"></path>
                            </svg>
                        </button>
                        <button class="kg-video-mute-icon kg-video-hide">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M16.177 4.3a.248.248 0 0 0 .073-.176v-1.1a1 1 0 0 0-1.061-1 9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h.114a.251.251 0 0 0 .177-.073ZM23.707 1.706A1 1 0 0 0 22.293.292l-22 22a1 1 0 0 0 0 1.414l.009.009a1 1 0 0 0 1.405-.009l6.63-6.631A.251.251 0 0 1 8.515 17a.245.245 0 0 1 .177.075 10.081 10.081 0 0 0 6.5 2.92 1 1 0 0 0 1.061-1V9.266a.247.247 0 0 1 .073-.176Z"></path>
                            </svg>
                        </button>
                        <input type="range" class="kg-video-volume-slider" max="100" value="100"/>
                    </div>
                </div>
            </div>
            ${node.getCaption() ? `<figcaption>${node.getCaption()}</figcaption>` : ''}
        </figure>
    `;
}
function emailCardTemplate(_ref2) {
  let {
    node,
    options,
    cardClasses
  } = _ref2;
  const thumbnailSrc = node.getCustomThumbnailSrc() || node.getThumbnailSrc();
  const emailTemplateMaxWidth = 600;
  const aspectRatio = node.getVideoWidth() / node.getVideoHeight();
  const emailSpacerWidth = Math.round(emailTemplateMaxWidth / 4);
  const emailSpacerHeight = Math.round(emailTemplateMaxWidth / aspectRatio);
  const posterSpacerSrc = `https://img.spacergif.org/v1/${emailSpacerWidth}x${emailSpacerHeight}/0a/spacer.png`;
  const outlookCircleLeft = Math.round(emailTemplateMaxWidth / 2 - 39);
  const outlookCircleTop = Math.round(emailSpacerHeight / 2 - 39);
  const outlookPlayLeft = Math.round(emailTemplateMaxWidth / 2 - 11);
  const outlookPlayTop = Math.round(emailSpacerHeight / 2 - 17);
  return `
         <figure class="${cardClasses}">
            <!--[if !mso !vml]-->
            <a class="kg-video-preview" href="${options.postUrl}" aria-label="Play video" style="mso-hide: all">
                <table
                    cellpadding="0"
                    cellspacing="0"
                    border="0"
                    width="100%"
                    background="${thumbnailSrc}"
                    role="presentation"
                    style="background: url('${thumbnailSrc}') left top / cover; mso-hide: all"
                >
                    <tr style="mso-hide: all">
                        <td width="25%" style="visibility: hidden; mso-hide: all">
                            <img src="${posterSpacerSrc}" alt="" width="100%" border="0" style="height: auto; opacity: 0; visibility: hidden; mso-hide: all;">
                        </td>
                        <td width="50%" align="center" valign="middle" style="vertical-align: middle; mso-hide: all;">
                            <div class="kg-video-play-button" style="mso-hide: all"><div style="mso-hide: all"></div></div>
                        </td>
                        <td width="25%" style="mso-hide: all">&nbsp;</td>
                    </tr>
                </table>
            </a>
            <!--[endif]-->

            <!--[if vml]>
            <v:group xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" coordsize="${emailTemplateMaxWidth},${emailSpacerHeight}" coordorigin="0,0" href="${options.postUrl}" style="width:${emailTemplateMaxWidth}px;height:${emailSpacerHeight}px;">
                <v:rect fill="t" stroked="f" style="position:absolute;width:${emailTemplateMaxWidth};height:${emailSpacerHeight};"><v:fill src="${thumbnailSrc}" type="frame"/></v:rect>
                <v:oval fill="t" strokecolor="white" strokeweight="4px" style="position:absolute;left:${outlookCircleLeft};top:${outlookCircleTop};width:78;height:78"><v:fill color="black" opacity="30%" /></v:oval>
                <v:shape coordsize="24,32" path="m,l,32,24,16,xe" fillcolor="white" stroked="f" style="position:absolute;left:${outlookPlayLeft};top:${outlookPlayTop};width:30;height:34;" />
            </v:group>
            <![endif]-->

            ${node.getCaption() ? `<figcaption>${node.getCaption()}</figcaption>` : ''}
        </figure>
        `;
}
function getCardClasses(node) {
  let cardClasses = ['kg-card kg-video-card'];
  if (node.getCardWidth()) {
    cardClasses.push(`kg-width-${node.getCardWidth()}`);
  }
  if (node.getCaption()) {
    cardClasses.push(`kg-card-hascaption`);
  }
  return cardClasses;
}

const INSERT_VIDEO_COMMAND = createCommand();
const NODE_TYPE$1 = 'video';
class VideoNode extends KoenigDecoratorNode {
  // payload properties
  __src;
  __caption;
  __width;
  __height;
  __duration;
  __thumbnailSrc;
  __customThumbnailSrc;
  __cardWidth;
  __loop;
  static getType() {
    return NODE_TYPE$1;
  }
  static clone(node) {
    return new this(node.getDataset(), node.__key);
  }

  // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
  static get urlTransformMap() {
    return {
      src: 'url',
      thumbnailSrc: 'url',
      customThumbnailSrc: 'url',
      caption: 'html'
    };
  }
  getDataset() {
    const self = this.getLatest();
    return {
      src: self.__src,
      caption: self.__caption,
      width: self.__width,
      height: self.__height,
      duration: self.__duration,
      thumbnailSrc: self.__thumbnailSrc,
      customThumbnailSrc: self.__customThumbnailSrc,
      cardWidth: self.__cardWidth,
      loop: self.__loop
    };
  }
  constructor() {
    let {
      src,
      caption,
      width,
      height,
      duration,
      thumbnailSrc,
      customThumbnailSrc,
      cardWidth,
      loop
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    super(key);
    this.__src = src || '';
    this.__caption = caption || '';
    this.__width = width || null;
    this.__height = height || null;
    this.__duration = duration || 0;
    this.__thumbnailSrc = thumbnailSrc || '';
    this.__customThumbnailSrc = customThumbnailSrc || '';
    this.__cardWidth = cardWidth || 'regular';
    this.__loop = !!loop;
  }
  static importJSON(serializedNode) {
    const {
      src,
      caption,
      width,
      height,
      duration,
      thumbnailSrc,
      customThumbnailSrc,
      cardWidth,
      loop
    } = serializedNode;
    const node = new this({
      src,
      caption,
      width,
      height,
      duration,
      thumbnailSrc,
      customThumbnailSrc,
      cardWidth,
      loop
    });
    return node;
  }
  exportJSON() {
    // checks if src is a data string
    const src = this.getSrc();
    const isBlob = src.startsWith('data:');
    const dataset = {
      type: NODE_TYPE$1,
      version: 1,
      src: isBlob ? '<base64String>' : this.getSrc(),
      caption: this.getCaption(),
      width: this.getVideoWidth(),
      height: this.getVideoHeight(),
      duration: this.getDuration(),
      thumbnailSrc: this.getThumbnailSrc(),
      customThumbnailSrc: this.getCustomThumbnailSrc(),
      cardWidth: this.getCardWidth(),
      loop: this.getLoop()
    };
    return dataset;
  }
  static importDOM() {
    const parser = new VideoParser(this);
    return parser.DOMConversionMap;
  }
  exportDOM() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const element = renderVideoNodeToDOM(this, options);
    return {
      element
    };
  }

  /* c8 ignore start */
  createDOM() {
    const element = document.createElement('div');
    return element;
  }
  updateDOM() {
    return false;
  }
  isInline() {
    return false;
  }
  /* c8 ignore stop */

  getSrc() {
    const self = this.getLatest();
    return self.__src;
  }
  setSrc(src) {
    const writable = this.getWritable();
    return writable.__src = src;
  }
  getCaption() {
    const self = this.getLatest();
    return self.__caption;
  }
  setCaption(caption) {
    const writable = this.getWritable();
    return writable.__caption = caption;
  }
  getVideoWidth() {
    const self = this.getLatest();
    return self.__width;
  }
  setVideoWidth(width) {
    const writable = this.getWritable();
    return writable.__width = width;
  }
  getVideoHeight() {
    const self = this.getLatest();
    return self.__height;
  }
  setVideoHeight(height) {
    const writable = this.getWritable();
    return writable.__height = height;
  }
  getDuration() {
    const self = this.getLatest();
    return self.__duration;
  }
  getFormattedDuration() {
    const minutes = Math.floor(this.getDuration() / 60);
    const seconds = Math.floor(this.getDuration() - minutes * 60);
    const paddedSeconds = String(seconds).padStart(2, '0');
    const formattedDuration = `${minutes}:${paddedSeconds}`;
    return formattedDuration;
  }
  setDuration(duration) {
    const writable = this.getWritable();
    return writable.__duration = duration;
  }
  getThumbnailSrc() {
    const self = this.getLatest();
    return self.__thumbnailSrc;
  }
  setThumbnailSrc(thumbnailSrc) {
    const writable = this.getWritable();
    return writable.__thumbnailSrc = thumbnailSrc;
  }
  getCustomThumbnailSrc() {
    const self = this.getLatest();
    return self.__customThumbnailSrc;
  }
  setCustomThumbnailSrc(customThumbnailSrc) {
    const writable = this.getWritable();
    return writable.__customThumbnailSrc = customThumbnailSrc;
  }
  setCardWidth(cardWidth) {
    const writable = this.getWritable();
    return writable.__cardWidth = cardWidth;
  }
  getCardWidth() {
    const self = this.getLatest();
    return self.__cardWidth;
  }
  getLoop() {
    const self = this.getLatest();
    return self.__loop;
  }
  setLoop(loop) {
    const writable = this.getWritable();
    return writable.__loop = loop;
  }

  // should be overridden
  /* c8 ignore next 3 */
  decorate() {
    return '';
  }
  hasEditMode() {
    return true;
  }
  isEmpty() {
    return !this.__src;
  }
}
const $createVideoNode = dataset => {
  return new VideoNode(dataset);
};
function $isVideoNode(node) {
  return node instanceof VideoNode;
}

class AudioParser {
  constructor(NodeClass) {
    this.NodeClass = NodeClass;
  }
  get DOMConversionMap() {
    const self = this;
    return {
      div: nodeElem => {
        const isKgAudioCard = nodeElem.classList?.contains('kg-audio-card');
        if (nodeElem.tagName === 'DIV' && isKgAudioCard) {
          return {
            conversion(domNode) {
              const titleNode = domNode?.querySelector('.kg-audio-title');
              const audioNode = domNode?.querySelector('.kg-audio-player-container audio');
              const durationNode = domNode?.querySelector('.kg-audio-duration');
              const thumbnailNode = domNode?.querySelector('.kg-audio-thumbnail');
              const title = titleNode && titleNode.innerHTML.trim();
              const audioSrc = audioNode && audioNode.src;
              const thumbnailSrc = thumbnailNode && thumbnailNode.src;
              const durationText = durationNode && durationNode.innerHTML.trim();
              const payload = {
                src: audioSrc,
                title: title
              };
              if (thumbnailSrc) {
                payload.thumbnailSrc = thumbnailSrc;
              }
              if (durationText) {
                const [minutes, seconds = 0] = durationText.split(':');
                try {
                  payload.duration = parseInt(minutes) * 60 + parseInt(seconds);
                } catch (e) {
                  // ignore duration
                }
              }
              const node = new self.NodeClass(payload);
              return {
                node
              };
            },
            priority: 1
          };
        }
        return null;
      }
    };
  }
}

// WIP
function renderAudioNodeToDOM(node) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  /* c8 ignore start */
  if (!options.createDocument) {
    let document = typeof window !== 'undefined' && window.document;
    if (!document) {
      throw new Error('renderAudioNodeToDOM() must be passed a `createDocument` function as an option when used in a non-browser environment'); // eslint-disable-line
    }

    options.createDocument = function () {
      return document;
    };
  }
  /* c8 ignore stop */

  const document = options.createDocument();
  if (!node.getSrc() || node.getSrc().trim() === '') {
    return document.createTextNode('');
  }
  return frontendTemplate(node, document);
}
function frontendTemplate(node, document) {
  let thumbnailCls = 'kg-audio-thumbnail';
  let emptyThumbnailCls = 'kg-audio-thumbnail placeholder';
  if (!node.getThumbnailSrc()) {
    thumbnailCls += ' kg-audio-hide';
  } else {
    emptyThumbnailCls += ' kg-audio-hide';
  }
  const cardDiv = document.createElement('div');
  cardDiv.setAttribute('class', 'kg-card kg-audio-card');
  const img = document.createElement('img');
  img.src = node.getThumbnailSrc();
  img.alt = 'audio-thumbnail';
  img.setAttribute('class', thumbnailCls);
  cardDiv.appendChild(img);
  const emptyThumbnailDiv = document.createElement('div');
  emptyThumbnailDiv.setAttribute('class', emptyThumbnailCls);
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '24');
  svg.setAttribute('height', '24');
  svg.setAttribute('fill', 'none');
  const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path1.setAttribute('fill-rule', 'evenodd');
  path1.setAttribute('clip-rule', 'evenodd');
  path1.setAttribute('d', 'M7.5 15.33a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm-2.25.75a2.25 2.25 0 1 1 4.5 0 2.25 2.25 0 0 1-4.5 0ZM15 13.83a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm-2.25.75a2.25 2.25 0 1 1 4.5 0 2.25 2.25 0 0 1-4.5 0Z');
  svg.appendChild(path1);
  const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path2.setAttribute('fill-rule', 'evenodd');
  path2.setAttribute('clip-rule', 'evenodd');
  path2.setAttribute('d', 'M14.486 6.81A2.25 2.25 0 0 1 17.25 9v5.579a.75.75 0 0 1-1.5 0v-5.58a.75.75 0 0 0-.932-.727.755.755 0 0 1-.059.013l-4.465.744a.75.75 0 0 0-.544.72v6.33a.75.75 0 0 1-1.5 0v-6.33a2.25 2.25 0 0 1 1.763-2.194l4.473-.746Z');
  svg.appendChild(path2);
  const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path3.setAttribute('fill-rule', 'evenodd');
  path3.setAttribute('clip-rule', 'evenodd');
  path3.setAttribute('d', 'M3 1.5a.75.75 0 0 0-.75.75v19.5a.75.75 0 0 0 .75.75h18a.75.75 0 0 0 .75-.75V5.133a.75.75 0 0 0-.225-.535l-.002-.002-3-2.883A.75.75 0 0 0 18 1.5H3ZM1.409.659A2.25 2.25 0 0 1 3 0h15a2.25 2.25 0 0 1 1.568.637l.003.002 3 2.883a2.25 2.25 0 0 1 .679 1.61V21.75A2.25 2.25 0 0 1 21 24H3a2.25 2.25 0 0 1-2.25-2.25V2.25c0-.597.237-1.169.659-1.591Z');
  svg.appendChild(path3);
  emptyThumbnailDiv.appendChild(svg);
  cardDiv.appendChild(emptyThumbnailDiv);
  const audioPlayerContainer = document.createElement('div');
  audioPlayerContainer.setAttribute('class', 'kg-audio-player-container');
  const audioElement = document.createElement('audio');
  audioElement.setAttribute('src', node.getSrc());
  audioElement.setAttribute('preload', 'metadata');
  audioPlayerContainer.appendChild(audioElement);
  const audioTitle = document.createElement('div');
  audioTitle.setAttribute('class', 'kg-audio-title');
  audioTitle.textContent = node.getTitle();
  audioPlayerContainer.appendChild(audioTitle);
  const audioPlayer = document.createElement('div');
  audioPlayer.setAttribute('class', 'kg-audio-player');
  const audioPlayIcon = document.createElement('button');
  audioPlayIcon.setAttribute('class', 'kg-audio-play-icon');
  const audioPlayIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  audioPlayIconSvg.setAttribute('viewBox', '0 0 24 24');
  const playPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  playPath.setAttribute('d', 'M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z');
  audioPlayIconSvg.appendChild(playPath);
  audioPlayIcon.appendChild(audioPlayIconSvg);
  audioPlayer.appendChild(audioPlayIcon);
  const audioPauseIcon = document.createElement('button');
  audioPauseIcon.setAttribute('class', 'kg-audio-pause-icon kg-audio-hide');
  const audioPauseIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  audioPauseIconSvg.setAttribute('viewBox', '0 0 24 24');
  const rectSvg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  rectSvg.setAttribute('x', '3');
  rectSvg.setAttribute('y', '1');
  rectSvg.setAttribute('width', '7');
  rectSvg.setAttribute('height', '22');
  rectSvg.setAttribute('rx', '1.5');
  rectSvg.setAttribute('ry', '1.5');
  audioPauseIconSvg.appendChild(rectSvg);
  const rectSvg2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  rectSvg2.setAttribute('x', '14');
  rectSvg2.setAttribute('y', '1');
  rectSvg2.setAttribute('width', '7');
  rectSvg2.setAttribute('height', '22');
  rectSvg2.setAttribute('rx', '1.5');
  rectSvg2.setAttribute('ry', '1.5');
  audioPauseIconSvg.appendChild(rectSvg2);
  audioPauseIcon.appendChild(audioPauseIconSvg);
  audioPlayer.appendChild(audioPauseIcon);
  const audioDuration = document.createElement('span');
  audioDuration.setAttribute('class', 'kg-audio-current-time');
  audioDuration.textContent = '0:00';
  audioPlayer.appendChild(audioDuration);
  const audioDurationTotal = document.createElement('div');
  audioDurationTotal.setAttribute('class', 'kg-audio-time');
  audioDurationTotal.textContent = '/';
  const audioDUrationNode = document.createElement('span');
  audioDUrationNode.setAttribute('class', 'kg-audio-duration');
  audioDUrationNode.textContent = node.getDuration();
  audioDurationTotal.appendChild(audioDUrationNode);
  audioPlayer.appendChild(audioDurationTotal);
  const audioSlider = document.createElement('input');
  audioSlider.setAttribute('type', 'range');
  audioSlider.setAttribute('class', 'kg-audio-seek-slider');
  audioSlider.setAttribute('max', '100');
  audioSlider.setAttribute('value', '0');
  audioPlayer.appendChild(audioSlider);
  const playbackRate = document.createElement('button');
  playbackRate.setAttribute('class', 'kg-audio-playback-rate');
  playbackRate.innerHTML = '1&#215;'; // innerHTML not textContent because we need the HTML entity
  audioPlayer.appendChild(playbackRate);
  const unmuteIcon = document.createElement('button');
  unmuteIcon.setAttribute('class', 'kg-audio-unmute-icon');
  const unmuteIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  unmuteIconSvg.setAttribute('viewBox', '0 0 24 24');
  const unmutePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  unmutePath.setAttribute('d', 'M15.189 2.021a9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1.794a.249.249 0 0 1 .221.133 9.73 9.73 0 0 0 7.924 4.85h.06a1 1 0 0 0 1-1V3.02a1 1 0 0 0-1.06-.998Z');
  unmuteIconSvg.appendChild(unmutePath);
  unmuteIcon.appendChild(unmuteIconSvg);
  audioPlayer.appendChild(unmuteIcon);
  const muteIcon = document.createElement('button');
  muteIcon.setAttribute('class', 'kg-audio-mute-icon kg-audio-hide');
  const muteIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  muteIconSvg.setAttribute('viewBox', '0 0 24 24');
  const mutePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  mutePath.setAttribute('d', 'M16.177 4.3a.248.248 0 0 0 .073-.176v-1.1a1 1 0 0 0-1.061-1 9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h.114a.251.251 0 0 0 .177-.073ZM23.707 1.706A1 1 0 0 0 22.293.292l-22 22a1 1 0 0 0 0 1.414l.009.009a1 1 0 0 0 1.405-.009l6.63-6.631A.251.251 0 0 1 8.515 17a.245.245 0 0 1 .177.075 10.081 10.081 0 0 0 6.5 2.92 1 1 0 0 0 1.061-1V9.266a.247.247 0 0 1 .073-.176Z');
  muteIconSvg.appendChild(mutePath);
  muteIcon.appendChild(muteIconSvg);
  audioPlayer.appendChild(muteIcon);
  const volumeSlider = document.createElement('input');
  volumeSlider.setAttribute('type', 'range');
  volumeSlider.setAttribute('class', 'kg-audio-volume-slider');
  volumeSlider.setAttribute('max', '100');
  volumeSlider.setAttribute('value', '100');
  audioPlayer.appendChild(volumeSlider);
  audioPlayerContainer.appendChild(audioPlayer);
  cardDiv.appendChild(audioPlayerContainer);
  return cardDiv;
}

const INSERT_AUDIO_COMMAND = createCommand();
const NODE_TYPE = 'audio';
class AudioNode extends KoenigDecoratorNode {
  // payload properties
  __src;
  __title;
  __duration;
  __mimeType;
  __thumbnailSrc;
  static getType() {
    return NODE_TYPE;
  }
  static clone(node) {
    return new this(node.getDataset(), node.__key);
  }

  // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
  static get urlTransformMap() {
    return {
      src: 'url'
    };
  }
  getDataset() {
    const self = this.getLatest();
    return {
      src: self.__src,
      title: self.__title,
      duration: self.__duration,
      mimeType: self.__mimeType,
      thumbnailSrc: self.__thumbnailSrc
    };
  }
  constructor() {
    let {
      src,
      title,
      duration,
      thumbnailSrc,
      mimeType
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    super(key);
    this.__src = src || '';
    this.__title = title || '';
    this.__duration = duration || 0;
    this.__mimeType = mimeType || '';
    this.__thumbnailSrc = thumbnailSrc || '';
  }
  static importJSON(serializedNode) {
    const {
      src,
      title,
      duration,
      mimeType,
      thumbnailSrc
    } = serializedNode;
    const node = new this({
      src,
      title,
      mimeType,
      duration,
      thumbnailSrc
    });
    return node;
  }
  exportJSON() {
    // checks if src is a data string
    const src = this.getSrc();
    const isBlob = src.startsWith('data:');
    const dataset = {
      type: NODE_TYPE,
      version: 1,
      src: isBlob ? '<base64String>' : this.getSrc(),
      title: this.getTitle(),
      mimeType: this.getMimeType(),
      duration: this.getDuration(),
      thumbnailSrc: this.getThumbnailSrc()
    };
    return dataset;
  }
  static importDOM() {
    const parser = new AudioParser(this);
    return parser.DOMConversionMap;
  }
  exportDOM() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const element = renderAudioNodeToDOM(this, options);
    return {
      element
    };
  }

  /* c8 ignore start */
  createDOM() {
    const element = document.createElement('div');
    return element;
  }
  updateDOM() {
    return false;
  }
  isInline() {
    return false;
  }
  /* c8 ignore stop */

  getSrc() {
    const self = this.getLatest();
    return self.__src;
  }
  setSrc(src) {
    const writable = this.getWritable();
    return writable.__src = src;
  }
  getTitle() {
    const self = this.getLatest();
    return self.__title;
  }
  setTitle(title) {
    const writable = this.getWritable();
    return writable.__title = title;
  }
  getDuration() {
    const self = this.getLatest();
    return self.__duration;
  }
  setDuration(duration) {
    const writable = this.getWritable();
    return writable.__duration = duration;
  }
  getMimeType() {
    const self = this.getLatest();
    return self.__mimeType;
  }
  setMimeType(mimeType) {
    const writable = this.getWritable();
    return writable.__mimeType = mimeType;
  }
  getThumbnailSrc() {
    const self = this.getLatest();
    return self.__thumbnailSrc;
  }
  setThumbnailSrc(thumbnailSrc) {
    const writable = this.getWritable();
    return writable.__thumbnailSrc = thumbnailSrc;
  }

  // should be overridden
  /* c8 ignore next 3 */
  decorate() {
    return '';
  }
  hasEditMode() {
    return true;
  }
  isEmpty() {
    return !this.__src;
  }
}
const $createAudioNode = dataset => {
  return new AudioNode(dataset);
};
function $isAudioNode(node) {
  return node instanceof AudioNode;
}

// export convenience objects for use elsewhere
const DEFAULT_NODES = [CodeBlockNode, ImageNode, MarkdownNode, VideoNode, AudioNode];

export { $createAudioNode, $createCodeBlockNode, $createImageNode, $createMarkdownNode, $createVideoNode, $isAudioNode, $isCodeBlockNode, $isImageNode, $isKoenigCard, $isMarkdownNode, $isVideoNode, AudioNode, CodeBlockNode, DEFAULT_NODES, INSERT_AUDIO_COMMAND, INSERT_CODE_BLOCK_COMMAND, INSERT_IMAGE_COMMAND, INSERT_MARKDOWN_COMMAND, INSERT_VIDEO_COMMAND, ImageNode, ImageParser, KoenigDecoratorNode, MarkdownNode, UPLOAD_IMAGE_COMMAND, VideoNode };
//# sourceMappingURL=kg-default-nodes.js.map
