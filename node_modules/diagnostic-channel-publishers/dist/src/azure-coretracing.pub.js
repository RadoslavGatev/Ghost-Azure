"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var diagnostic_channel_1 = require("diagnostic-channel");
exports.AzureMonitorSymbol = "Azure_Monitor_Tracer";
var isPatched = false;
/**
 * By default, @azure/core-tracing default tracer is a NoopTracer.
 * This patching changes the default tracer to a patched BasicTracer
 * which emits ended spans as diag-channel events.
 *
 * The @opentelemetry/tracing package must be installed to use these patches
 * https://www.npmjs.com/package/@opentelemetry/tracing
 * @param coreTracing
 */
var azureCoreTracingPatchFunction = function (coreTracing) {
    if (isPatched) {
        // tracer is already cached -- noop
        return coreTracing;
    }
    try {
        var tracing = require("@opentelemetry/tracing");
        var api_1 = require("@opentelemetry/api");
        var tracerConfig = diagnostic_channel_1.channel.spanContextPropagator
            ? { contextManager: diagnostic_channel_1.channel.spanContextPropagator }
            : undefined;
        new tracing.BasicTracerProvider().register(tracerConfig);
        var tracer = api_1.trace.getTracer("applicationinsights tracer");
        // Patch startSpan instead of using spanProcessor.onStart because parentSpan must be
        // set while the span is constructed
        var startSpanOriginal_1 = tracer.startSpan;
        tracer.startSpan = function (name, options) {
            // if no parent span was provided, apply the current context
            if (!options || !options.parent) {
                var parentOperation = api_1.getSpan(api_1.context.active());
                if (parentOperation && parentOperation.operation && parentOperation.operation.traceparent) {
                    options = __assign({}, options, { parent: {
                            traceId: parentOperation.operation.traceparent.traceId,
                            spanId: parentOperation.operation.traceparent.spanId,
                            traceFlags: 1,
                        } });
                }
            }
            var span = startSpanOriginal_1.call(this, name, options);
            var originalEnd = span.end;
            span.end = function () {
                var result = originalEnd.apply(this, arguments);
                diagnostic_channel_1.channel.publish("azure-coretracing", span);
                return result;
            };
            return span;
        };
        api_1.getSpan(api_1.context.active()); // seed OpenTelemetryScopeManagerWrapper with "active" symbol
        tracer[exports.AzureMonitorSymbol] = true;
        coreTracing.setTracer(tracer); // recordSpanData is not present on BasicTracer - cast to any
        isPatched = true;
    }
    catch (e) { /* squash errors */ }
    return coreTracing;
};
exports.azureCoreTracing = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: azureCoreTracingPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("@azure/core-tracing", exports.azureCoreTracing);
}
exports.enable = enable;
//# sourceMappingURL=azure-coretracing.pub.js.map