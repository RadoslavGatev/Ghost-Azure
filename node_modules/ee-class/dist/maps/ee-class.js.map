{"version":3,"sources":["class.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ee-class.js","sourcesContent":["(function(root, factory) {\n    'use strict';\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        \n        define([], factory);\n    } else if (typeof module === 'object' && typeof module.exports === 'object') {\n        // Node\n\n        module.exports = factory();\n    } else {\n        // EE Namespace\n\n        // create namespace as needed\n        if (typeof root.ee !== 'object') root.ee = {};\n\n        // publish\n        root.ee.Class = factory();\n    }\n})(this, function() {\n    'use strict';\n\n\n    var   setSuper\n        , setSuperPrototype\n        , Class;\n\n\n    // set the super method on each method which is used to call the next method of the same name in the prototype chain\n    setSuper = function(name, base, proto, parent) {\n        base.super = function() {\n            var args, i, l;\n\n            if (base.___super) {\n                args = [];\n\n                // convert args into an arry in order\n                for (i = 0, l = arguments.length; i < l; i++) args.push(arguments[i]);\n\n                // call super\n                return base.___super.apply(this, args);\n            }\n            else throw new Error('The method «'+name+'» has no super «'+name+'» method on any protoype!');\n        };\n\n\n        // makes the local class definnition available to the parent scope\n        if (!base.local) Object.defineProperty(base, 'local', {value: parent});\n\n        if (proto && proto.prototype) setSuperPrototype(name, base, proto.prototype, parent);\n    };\n\n\n    // find the next method with the same name on the protoype chain\n    setSuperPrototype = function(name, base, proto, parent) {\n\n        // makes the local class definnition available to the parent scope\n        if (!base.local) Object.defineProperty(base, 'local', {value: parent});\n\n\n        if (proto) {\n            if (Object.hasOwnProperty.call(proto, name)){\n                Object.defineProperty(base, '___super', {value: proto[name]});\n            }\n            else if (!proto.___isEeClass && name === 'init' && typeof proto === 'object' && typeof proto.constructor === 'function') {\n                // a plain js object ... set it as super to the init constructor\n                Object.defineProperty(base, '___super', {value: proto.constructor});\n            }\n            else {\n                setSuperPrototype(name, base, typeof proto === 'object' ? Object.getPrototypeOf(proto) : null, parent);\n            }\n        }\n    };\n\n\n\n    Class = function(classDefinition) {\n        var   properties = {}\n            , classConstructor;\n\n        // not creating a class, creating a property descriptor insted\n        if (!(this instanceof Class)) {\n            return Object.create(Class, {value:{value: classDefinition, enumerable: true}});\n        }\n\n\n        // get properties from super class definition\n        if (classDefinition.inherits && classDefinition.inherits.___properties) properties = classDefinition.inherits.___properties;\n\n        // collect all properties\n        Object.keys(classDefinition).forEach(function(key){\n            var property = classDefinition[key];\n\n            // inherits from another class / prototype\n            if (key === 'inherits') return;\n\n            // map as method\n            else if (typeof property === 'function') {\n                properties[key] = {value: property, enumerable: key[0] !== '_'};\n\n                // this may be used to build more meaningful stack traces\n                if (!properties[key].value.displayName)  Object.defineProperty(properties[key].value, 'displayName', {value: key});\n\n                // check if there is an super method to call on any of the prototypes\n                setSuper(key, property, classDefinition.inherits, classDefinition);\n            }\n\n            // more analytics required\n            else if (typeof property === 'object' && Object.prototype.toString.call(property) === '[object Object]') {\n\n                // property descriptor\n                if (Object.hasOwnProperty.call(property, 'get') || Object.hasOwnProperty.call(property, 'value') || Object.hasOwnProperty.call(property, 'set')) {\n                    if (!Object.keys(property).some(function(key){ return ['get', 'set', 'value', 'enumerable', 'writable', 'configurable'].indexOf(key) === -1;})) {\n                        // there ar eno other keys on the obejct, we should expect a definition herre\n\n                        properties[key] = property;\n\n                        if (typeof property.value === 'function') {\n                            setSuper(key, property.value, classDefinition.inherits, classDefinition);\n\n                            // this may be used to build more meaningful stack traces\n                            if (!property.value.displayName) Object.defineProperty(property.value, 'displayName', {value: key});\n                        }\n                    }\n                    else {\n                        properties[key] = properties[key] = {value: property, enumerable: true, writable: true};\n                    }\n                }\n                else {\n                    properties[key] = properties[key] = {value: property, enumerable: true, writable: true};\n                }\n            }\n\n            // map as scalar property\n            else properties[key] = {value: property, enumerable: true, writable: true};\n        });\n\n\n        // check for es6 features\n        if (typeof Symbol === 'function' && Symbol.iterator in classDefinition) properties[Symbol.iterator] = {value: classDefinition[Symbol.iterator], writable: true};\n\n\n\n\n\n        // constructor function that is returned\n        // to the user\n        classConstructor = function(){\n            var   args = []\n                , result, i, l;\n\n\n            // check if the new keyword was forgotten\n            if (!(this instanceof classConstructor)) throw new Error('the class constructor was called without the «new» keyword!');\n\n            // convert args into an arry in order\n            for (i = 0, l = arguments.length; i < l; i++) args.push(arguments[i]);\n\n\n            // check if the class got a constructor method\n            if (this.init) result = this.init.apply(this, args);\n\n            // or we inherited from a constructor\n            else if (typeof classDefinition.inherits === 'function') classDefinition.inherits.apply(this, args);\n\n\n            // we return anything we got from the constructor as result\n            if (typeof result !== 'undefined') return result;\n        };\n\n\n\n\n        // set constructor prototype\n        classConstructor.prototype = Object.create(classDefinition.inherits ? (classDefinition.inherits.prototype ? classDefinition.inherits.prototype : classDefinition.inherits) : {}, properties);\n\n        // identify as ee class using the init function as its contructor\n        Object.defineProperty(classConstructor.prototype, '___isEeClass', {value:true});\n\n        return classConstructor;\n    };\n\n\n\n\n    // set enumerable property\n    Class.Enumerable = function() {\n        Object.defineProperty(this, 'enumerable', {value: true, enumerable: true});\n        return this;\n    };\n\n    // set configurable property\n    Class.Configurable = function() {\n        Object.defineProperty(this, 'configurable', {value: true, enumerable: true});\n        return this;\n    };\n\n    // set writable property\n    Class.Writable = function() {\n        Object.defineProperty(this, 'writable', {value: true, enumerable: true});\n        return this;\n    };\n\n    // return the class prototype\n    Class.proto = function(instance) {\n        return typeof instance === 'object' ? Object.getPrototypeOf(instance) : undefined;\n    };\n\n    // return all enumerable key of the class an its prototypes\n    Class.keys = function(instance) {\n        var keys = [];\n        for (var key in instance) keys.push(key);\n        return keys;\n    };\n\n    // define a proeprty on an objetc\n    Class.define = function(instance, property, descriptor){\n        Object.defineProperty(instance, property, descriptor);\n    };\n\n    // implement a class on an object\n    Class.implement = function(source, target) {\n        Class.keys(source).forEach(function(key){\n            target[key] = source[key];\n        });\n\n        return target;\n    };\n\n    // list all methods of a class\n    Class.inspect = function(obj, description) {\n        description = description || {};\n\n        Object.getOwnPropertyNames(obj).sort().forEach(function(name) {\n            if (typeof obj[name] === 'function') {\n                description[name] = function(){};\n            }\n            else if (name !== '___isEeClass') {\n                description[name] = obj[name];\n            }\n        });\n\n        if (Object.getPrototypeOf(obj)) {\n            description.super = {};\n            Class.inspect(Object.getPrototypeOf(obj), description.super);\n        }\n\n        return description;\n    };\n\n\n    return Class;\n});\n"],"sourceRoot":"/source/"}