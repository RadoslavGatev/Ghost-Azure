{"version":3,"file":"SamplingTelemetryProcessor.js","sourceRoot":"","sources":["../../TelemetryProcessors/SamplingTelemetryProcessor.ts"],"names":[],"mappings":";;AAAA,qDAAwD;AAGxD;;GAEG;AACH,oCAA2C,QAAqC,EAAE,cAA0D;IACxI,IAAI,kBAAkB,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,mCAAmC;IACjF,IAAI,WAAW,GAAG,KAAK,CAAC;IAExB,EAAE,CAAC,CAAC,kBAAkB,KAAK,IAAI,IAAI,kBAAkB,KAAK,SAAS,IAAI,kBAAkB,IAAI,GAAG,CAAC,CAAC,CAAC;QAC/F,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,IAAI,SAAS,CAAC,aAAa,CAAC,MAAM,KAAK,SAAS,CAAC,uBAAuB,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAyC,CAAC,CAAC,CAAC,CAAC;QACxJ,6CAA6C;QAC7C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,CAAC,kBAAkB,IAAI,cAAc,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1F,mGAAmG;QACnG,WAAW,GAAG,mBAAmB,CAAC,cAAc,CAAC,kBAAkB,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,kBAAkB,CAAC;IAC3G,CAAC;IAAC,IAAI,CAAC,CAAC;QACJ,oGAAoG;QACpG,WAAW,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,GAAG,kBAAkB,CAAC;IAC7D,CAAC;IAED,MAAM,CAAC,WAAW,CAAC;AACvB,CAAC;AAlBD,gEAkBC;AAED,8BAA8B;AAC9B,6BAAoC,KAAa;IAC7C,IAAI,SAAS,GAAG,CAAC,UAAU,CAAC;IAC5B,IAAI,SAAS,GAAG,UAAU,CAAC;IAC3B,IAAI,IAAI,GAAG,IAAI,CAAC;IAEhB,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QACT,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IAED,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACtB,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;IAC1B,CAAC;IAED,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACpC,uGAAuG;QACvG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAClE,CAAC;IAED,IAAI,GAAG,IAAI,IAAI,SAAS,GAAG,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACtD,MAAM,CAAC,CAAC,IAAI,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC;AACpC,CAAC;AApBD,kDAoBC","sourcesContent":["import Contracts = require(\"../Declarations/Contracts\");\r\nimport { CorrelationContext } from \"../AutoCollection/CorrelationContextManager\";\r\n\r\n/**\r\n *  A telemetry processor that handles sampling.\r\n */\r\nexport function samplingTelemetryProcessor(envelope: Contracts.EnvelopeTelemetry, contextObjects: { correlationContext: CorrelationContext }): boolean {\r\n    var samplingPercentage = envelope.sampleRate; // Set for us in Client.getEnvelope\r\n    var isSampledIn = false;\r\n\r\n    if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {\r\n        return true;\r\n    } else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType as Contracts.TelemetryTypeValues)) {\r\n        // Exclude MetricData telemetry from sampling\r\n        return true;\r\n    } else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {\r\n        // If we're using dependency correlation, sampling should retain all telemetry from a given request\r\n        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;\r\n    } else {\r\n        // If we're not using dependency correlation, sampling should use a random distribution on each item\r\n        isSampledIn = (Math.random() * 100) < samplingPercentage;\r\n    }\r\n\r\n    return isSampledIn;\r\n}\r\n\r\n/** Ported from AI .NET SDK */\r\nexport function getSamplingHashCode(input: string): number {\r\n    var csharpMin = -2147483648;\r\n    var csharpMax = 2147483647;\r\n    var hash = 5381;\r\n\r\n    if (!input) {\r\n        return 0;\r\n    }\r\n\r\n    while (input.length < 8) {\r\n        input = input + input;\r\n    }\r\n\r\n    for (var i = 0; i < input.length; i++) {\r\n        // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)\r\n        hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i) | 0);\r\n    }\r\n\r\n    hash = hash <= csharpMin ? csharpMax : Math.abs(hash);\r\n    return (hash / csharpMax) * 100;\r\n}"]}