import { Baggage, BaggageObj, HttpHeaderValue, TraceparentData } from '@sentry/types';
export declare const BAGGAGE_HEADER_NAME = "baggage";
export declare const SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
export declare const SENTRY_BAGGAGE_KEY_PREFIX_REGEX: RegExp;
/**
 * Max length of a serialized baggage string
 *
 * https://www.w3.org/TR/baggage/#limits
 */
export declare const MAX_BAGGAGE_STRING_LENGTH = 8192;
/** Create an instance of Baggage */
export declare function createBaggage(initItems: BaggageObj, baggageString?: string, mutable?: boolean): Baggage;
/** Get a value from baggage */
export declare function getBaggageValue(baggage: Baggage, key: keyof BaggageObj): BaggageObj[keyof BaggageObj];
/** Add a value to baggage */
export declare function setBaggageValue(baggage: Baggage, key: keyof BaggageObj, value: BaggageObj[keyof BaggageObj]): void;
/** Check if the Sentry part of the passed baggage (i.e. the first element in the tuple) is empty */
export declare function isSentryBaggageEmpty(baggage: Baggage): boolean;
/** Returns Sentry specific baggage values */
export declare function getSentryBaggageItems(baggage: Baggage): BaggageObj;
/**
 * Returns 3rd party baggage string of @param baggage
 * @param baggage
 */
export declare function getThirdPartyBaggage(baggage: Baggage): string;
/**
 * Checks if baggage is mutable
 * @param baggage
 * @returns true if baggage is mutable, else false
 */
export declare function isBaggageMutable(baggage: Baggage): boolean;
/**
 * Sets the passed baggage immutable
 * @param baggage
 */
export declare function setBaggageImmutable(baggage: Baggage): void;
/** Serialize a baggage object */
export declare function serializeBaggage(baggage: Baggage): string;
/**
 * Parse a baggage header from a string or a string array and return a Baggage object
 *
 * If @param includeThirdPartyEntries is set to true, third party baggage entries are added to the Baggage object
 * (This is necessary for merging potentially pre-existing baggage headers in outgoing requests with
 * our `sentry-` values)
 */
export declare function parseBaggageHeader(inputBaggageValue: HttpHeaderValue, includeThirdPartyEntries?: boolean): Baggage;
/**
 * Merges the baggage header we saved from the incoming request (or meta tag) with
 * a possibly created or modified baggage header by a third party that's been added
 * to the outgoing request header.
 *
 * In case @param headerBaggageString exists, we can safely add the the 3rd party part of @param headerBaggage
 * with our @param incomingBaggage. This is possible because if we modified anything beforehand,
 * it would only affect parts of the sentry baggage (@see Baggage interface).
 *
 * @param incomingBaggage the baggage header of the incoming request that might contain sentry entries
 * @param thirdPartyBaggageHeader possibly existing baggage header string or string[] added from a third
 *        party to the request headers
 *
 * @return a merged and serialized baggage string to be propagated with the outgoing request
 */
export declare function mergeAndSerializeBaggage(incomingBaggage?: Baggage, thirdPartyBaggageHeader?: HttpHeaderValue): string;
/**
 * Helper function that takes a raw baggage string (if available) and the processed sentry-trace header
 * data (if available), parses the baggage string and creates a Baggage object
 * If there is no baggage string, it will create an empty Baggage object.
 * In a second step, this functions determines if the created Baggage object should be set immutable
 * to prevent mutation of the Sentry data.
 *
 * Extracted this logic to a function because it's duplicated in a lot of places.
 *
 * @param rawBaggageValue
 * @param sentryTraceHeader
 */
export declare function parseBaggageSetMutability(rawBaggageValue: HttpHeaderValue | false | undefined, sentryTraceHeader: TraceparentData | string | false | undefined | null): Baggage;
//# sourceMappingURL=baggage.d.ts.map