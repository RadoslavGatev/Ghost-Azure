{"version":3,"file":"handlers.js","sources":["../../src/handlers.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { captureException, getCurrentHub, startTransaction, withScope } from '@sentry/core';\nimport { Event, Span } from '@sentry/types';\nimport {\n  AddRequestDataToEventOptions,\n  addRequestDataToTransaction,\n  extractPathForTransaction,\n  extractTraceparentData,\n  isString,\n  logger,\n  parseBaggageSetMutability,\n} from '@sentry/utils';\nimport * as domain from 'domain';\nimport * as http from 'http';\n\nimport { NodeClient } from './client';\n// TODO (v8 / XXX) Remove these imports\nimport type { ParseRequestOptions } from './requestDataDeprecated';\nimport { parseRequest } from './requestDataDeprecated';\nimport { addRequestDataToEvent, extractRequestData, flush, isAutoSessionTrackingEnabled } from './sdk';\n\n/**\n * Express-compatible tracing handler.\n * @see Exposed as `Handlers.tracingHandler`\n */\nexport function tracingHandler(): (\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error?: any) => void,\n) => void {\n  return function sentryTracingMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    const hub = getCurrentHub();\n    const options = hub.getClient()?.getOptions();\n\n    if (!options || req.method?.toUpperCase() === 'OPTIONS' || req.method?.toUpperCase() === 'HEAD') {\n      return next();\n    }\n\n    // TODO: This is the `hasTracingEnabled` check, but we're doing it manually since `@sentry/tracing` isn't a\n    // dependency of `@sentry/node`. Long term, that function should probably move to `@sentry/hub.\n    if (!('tracesSampleRate' in options) && !('tracesSampler' in options)) {\n      __DEBUG_BUILD__ &&\n        logger.warn(\n          'Sentry `tracingHandler` is being used, but tracing is disabled. Please enable tracing by setting ' +\n            'either `tracesSampleRate` or `tracesSampler` in your `Sentry.init()` options.',\n        );\n      return next();\n    }\n\n    // If there is a trace header set, we extract the data from it (parentSpanId, traceId, and sampling decision)\n    const traceparentData =\n      req.headers && isString(req.headers['sentry-trace']) && extractTraceparentData(req.headers['sentry-trace']);\n    const rawBaggageString = req.headers && isString(req.headers.baggage) && req.headers.baggage;\n\n    const baggage = parseBaggageSetMutability(rawBaggageString, traceparentData);\n\n    const [name, source] = extractPathForTransaction(req, { path: true, method: true });\n    const transaction = startTransaction(\n      {\n        name,\n        op: 'http.server',\n        ...traceparentData,\n        metadata: { baggage, source },\n      },\n      // extra context passed to the tracesSampler\n      { request: extractRequestData(req) },\n    );\n\n    // We put the transaction on the scope so users can attach children to it\n    hub.configureScope(scope => {\n      scope.setSpan(transaction);\n    });\n\n    // We also set __sentry_transaction on the response so people can grab the transaction there to add\n    // spans to it later.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    (res as any).__sentry_transaction = transaction;\n\n    res.once('finish', () => {\n      // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the transaction\n      // closes\n      setImmediate(() => {\n        addRequestDataToTransaction(transaction, req);\n        transaction.setHttpStatus(res.statusCode);\n        transaction.finish();\n      });\n    });\n\n    next();\n  };\n}\n\nexport type RequestHandlerOptions =\n  // TODO (v8 / XXX) Remove ParseRequestOptions type and eslint override\n  // eslint-disable-next-line deprecation/deprecation\n  | (ParseRequestOptions | AddRequestDataToEventOptions) & {\n      flushTimeout?: number;\n    };\n\n/**\n * Express compatible request handler.\n * @see Exposed as `Handlers.requestHandler`\n */\nexport function requestHandler(\n  options?: RequestHandlerOptions,\n): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void {\n  const currentHub = getCurrentHub();\n  const client = currentHub.getClient<NodeClient>();\n  // Initialise an instance of SessionFlusher on the client when `autoSessionTracking` is enabled and the\n  // `requestHandler` middleware is used indicating that we are running in SessionAggregates mode\n  if (client && isAutoSessionTrackingEnabled(client)) {\n    client.initSessionFlusher();\n\n    // If Scope contains a Single mode Session, it is removed in favor of using Session Aggregates mode\n    const scope = currentHub.getScope();\n    if (scope && scope.getSession()) {\n      scope.setSession();\n    }\n  }\n\n  return function sentryRequestMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    // TODO (v8 / XXX) Remove this shim and just use `addRequestDataToEvent`\n    let backwardsCompatibleEventProcessor: (event: Event) => Event;\n    if (options && 'include' in options) {\n      backwardsCompatibleEventProcessor = (event: Event) => addRequestDataToEvent(event, req, options);\n    } else {\n      // eslint-disable-next-line deprecation/deprecation\n      backwardsCompatibleEventProcessor = (event: Event) => parseRequest(event, req, options as ParseRequestOptions);\n    }\n\n    if (options && options.flushTimeout && options.flushTimeout > 0) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _end = res.end;\n      res.end = function (chunk?: any | (() => void), encoding?: string | (() => void), cb?: () => void): void {\n        void flush(options.flushTimeout)\n          .then(() => {\n            _end.call(this, chunk, encoding, cb);\n          })\n          .then(null, e => {\n            __DEBUG_BUILD__ && logger.error(e);\n            _end.call(this, chunk, encoding, cb);\n          });\n      };\n    }\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n    local.on('error', next);\n\n    local.run(() => {\n      const currentHub = getCurrentHub();\n\n      currentHub.configureScope(scope => {\n        scope.addEventProcessor(backwardsCompatibleEventProcessor);\n        const client = currentHub.getClient<NodeClient>();\n        if (isAutoSessionTrackingEnabled(client)) {\n          const scope = currentHub.getScope();\n          if (scope) {\n            // Set `status` of `RequestSession` to Ok, at the beginning of the request\n            scope.setRequestSession({ status: 'ok' });\n          }\n        }\n      });\n\n      res.once('finish', () => {\n        const client = currentHub.getClient<NodeClient>();\n        if (isAutoSessionTrackingEnabled(client)) {\n          setImmediate(() => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (client && (client as any)._captureRequestSession) {\n              // Calling _captureRequestSession to capture request session at the end of the request by incrementing\n              // the correct SessionAggregates bucket i.e. crashed, errored or exited\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              (client as any)._captureRequestSession();\n            }\n          });\n        }\n      });\n      next();\n    });\n  };\n}\n\n/** JSDoc */\ninterface MiddlewareError extends Error {\n  status?: number | string;\n  statusCode?: number | string;\n  status_code?: number | string;\n  output?: {\n    statusCode?: number | string;\n  };\n}\n\n/** JSDoc */\nfunction getStatusCodeFromResponse(error: MiddlewareError): number {\n  const statusCode = error.status || error.statusCode || error.status_code || (error.output && error.output.statusCode);\n  return statusCode ? parseInt(statusCode as string, 10) : 500;\n}\n\n/** Returns true if response code is internal server error */\nfunction defaultShouldHandleError(error: MiddlewareError): boolean {\n  const status = getStatusCodeFromResponse(error);\n  return status >= 500;\n}\n\n/**\n * Express compatible error handler.\n * @see Exposed as `Handlers.errorHandler`\n */\nexport function errorHandler(options?: {\n  /**\n   * Callback method deciding whether error should be captured and sent to Sentry\n   * @param error Captured middleware error\n   */\n  shouldHandleError?(error: MiddlewareError): boolean;\n}): (\n  error: MiddlewareError,\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error: MiddlewareError) => void,\n) => void {\n  return function sentryErrorMiddleware(\n    error: MiddlewareError,\n    _req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error: MiddlewareError) => void,\n  ): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const shouldHandleError = (options && options.shouldHandleError) || defaultShouldHandleError;\n\n    if (shouldHandleError(error)) {\n      withScope(_scope => {\n        // For some reason we need to set the transaction on the scope again\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        const transaction = (res as any).__sentry_transaction as Span;\n        if (transaction && _scope.getSpan() === undefined) {\n          _scope.setSpan(transaction);\n        }\n\n        const client = getCurrentHub().getClient<NodeClient>();\n        if (client && isAutoSessionTrackingEnabled(client)) {\n          // Check if the `SessionFlusher` is instantiated on the client to go into this branch that marks the\n          // `requestSession.status` as `Crashed`, and this check is necessary because the `SessionFlusher` is only\n          // instantiated when the the`requestHandler` middleware is initialised, which indicates that we should be\n          // running in SessionAggregates mode\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          const isSessionAggregatesMode = (client as any)._sessionFlusher !== undefined;\n          if (isSessionAggregatesMode) {\n            const requestSession = _scope.getRequestSession();\n            // If an error bubbles to the `errorHandler`, then this is an unhandled error, and should be reported as a\n            // Crashed session. The `_requestSession.status` is checked to ensure that this error is happening within\n            // the bounds of a request, and if so the status is updated\n            if (requestSession && requestSession.status !== undefined) {\n              requestSession.status = 'crashed';\n            }\n          }\n        }\n\n        const eventId = captureException(error);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        (res as any).sentry = eventId;\n        next(error);\n      });\n\n      return;\n    }\n\n    next(error);\n  };\n}\n\n// TODO (v8 / #5257): Remove this\n// eslint-disable-next-line deprecation/deprecation\nexport type { ParseRequestOptions, ExpressRequest } from './requestDataDeprecated';\n// eslint-disable-next-line deprecation/deprecation\nexport { parseRequest, extractRequestData } from './requestDataDeprecated';\n"],"names":[],"mappings":";;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyEA;;AASA;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgFA;;AAEA;;AAUA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;;AAEA;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDA;;AAEA;AAEA;;;;;;"}