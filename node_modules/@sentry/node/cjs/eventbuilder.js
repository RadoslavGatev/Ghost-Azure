Object.defineProperty(exports, '__esModule', { value: true });

var hub = require('@sentry/hub');
var utils = require('@sentry/utils');

/**
 * Extracts stack frames from the error.stack string
 */
function parseStackFrames(stackParser, error) {
  return stackParser(error.stack || '', 1);
}

/**
 * Extracts stack frames from the error and builds a Sentry Exception
 */
function exceptionFromError(stackParser, error) {
  var exception = {
    type: error.name || error.constructor.name,
    value: error.message,
  };

  var frames = parseStackFrames(stackParser, error);
  if (frames.length) {
    exception.stacktrace = { frames };
  }

  return exception;
}

/**
 * Builds and Event from a Exception
 * @hidden
 */
function eventFromUnknownInput(stackParser, exception, hint) {
    let ex = exception;
  var providedMechanism =
    hint && hint.data && (hint.data ).mechanism;
  var mechanism = providedMechanism || {
    handled: true,
    type: 'generic',
  };

  if (!utils.isError(exception)) {
    if (utils.isPlainObject(exception)) {
      // This will allow us to group events based on top-level keys
      // which is much better than creating new group when any key/value change
      var message = `Non-Error exception captured with keys: ${utils.extractExceptionKeysForMessage(exception)}`;

      hub.getCurrentHub().configureScope(scope => {
        scope.setExtra('__serialized__', utils.normalizeToSize(exception));
      });

      ex = (hint && hint.syntheticException) || new Error(message);
      (ex ).message = message;
    } else {
      // This handles when someone does: `throw "something awesome";`
      // We use synthesized Error here so we can extract a (rough) stack trace.
      ex = (hint && hint.syntheticException) || new Error(exception );
      (ex ).message = exception ;
    }
    mechanism.synthetic = true;
  }

  var event = {
    exception: {
      values: [exceptionFromError(stackParser, ex )],
    },
  };

  utils.addExceptionTypeValue(event, undefined, undefined);
  utils.addExceptionMechanism(event, mechanism);

  return {
    ...event,
    event_id: hint && hint.event_id,
  };
}

/**
 * Builds and Event from a Message
 * @hidden
 */
function eventFromMessage(
  stackParser,
  message,
    level = 'info',
  hint,
  attachStacktrace,
) {
  var event = {
    event_id: hint && hint.event_id,
    level,
    message,
  };

  if (attachStacktrace && hint && hint.syntheticException) {
    var frames = parseStackFrames(stackParser, hint.syntheticException);
    if (frames.length) {
      event.exception = {
        values: [
          {
            value: message,
            stacktrace: { frames },
          },
        ],
      };
    }
  }

  return event;
}

exports.eventFromMessage = eventFromMessage;
exports.eventFromUnknownInput = eventFromUnknownInput;
exports.exceptionFromError = exceptionFromError;
exports.parseStackFrames = parseStackFrames;
//# sourceMappingURL=eventbuilder.js.map
