{"version":3,"file":"sdk.js","sources":["../../src/sdk.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { getCurrentHub, getIntegrationsToSetup, initAndBind, Integrations as CoreIntegrations } from '@sentry/core';\nimport { getMainCarrier, setHubOnCarrier } from '@sentry/hub';\nimport { Event, ExtractedNodeRequestData, SessionStatus, StackParser } from '@sentry/types';\nimport {\n  addRequestDataToEvent as _addRequestDataToEvent,\n  AddRequestDataToEventOptions,\n  createStackParser,\n  CrossPlatformRequest,\n  extractRequestData as _extractRequestData,\n  getGlobalObject,\n  logger,\n  nodeStackLineParser,\n  stackParserFromStackParserOptions,\n} from '@sentry/utils';\nimport * as cookie from 'cookie';\nimport * as domain from 'domain';\nimport * as url from 'url';\n\nimport { NodeClient } from './client';\nimport { Console, ContextLines, Http, LinkedErrors, OnUncaughtException, OnUnhandledRejection } from './integrations';\nimport { getModule } from './module';\nimport { makeNodeTransport } from './transports';\nimport { NodeClientOptions, NodeOptions } from './types';\n\nexport const defaultIntegrations = [\n  // Common\n  new CoreIntegrations.InboundFilters(),\n  new CoreIntegrations.FunctionToString(),\n  new ContextLines(),\n  // Native Wrappers\n  new Console(),\n  new Http(),\n  // Global Handlers\n  new OnUncaughtException(),\n  new OnUnhandledRejection(),\n  // Misc\n  new LinkedErrors(),\n];\n\n/**\n * The Sentry Node SDK Client.\n *\n * To use this SDK, call the {@link init} function as early as possible in the\n * main entry module. To set context information or send manual events, use the\n * provided methods.\n *\n * @example\n * ```\n *\n * const { init } = require('@sentry/node');\n *\n * init({\n *   dsn: '__DSN__',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * const { configureScope } = require('@sentry/node');\n * configureScope((scope: Scope) => {\n *   scope.setExtra({ battery: 0.7 });\n *   scope.setTag({ user_mode: 'admin' });\n *   scope.setUser({ id: '4711' });\n * });\n * ```\n *\n * @example\n * ```\n *\n * const { addBreadcrumb } = require('@sentry/node');\n * addBreadcrumb({\n *   message: 'My Breadcrumb',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * const Sentry = require('@sentry/node');\n * Sentry.captureMessage('Hello, world!');\n * Sentry.captureException(new Error('Good bye'));\n * Sentry.captureEvent({\n *   message: 'Manual',\n *   stacktrace: [\n *     // ...\n *   ],\n * });\n * ```\n *\n * @see {@link NodeOptions} for documentation on configuration options.\n */\nexport function init(options: NodeOptions = {}): void {\n  const carrier = getMainCarrier();\n  const autoloadedIntegrations = carrier.__SENTRY__?.integrations || [];\n\n  options.defaultIntegrations =\n    options.defaultIntegrations === false\n      ? []\n      : [\n          ...(Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : defaultIntegrations),\n          ...autoloadedIntegrations,\n        ];\n\n  if (options.dsn === undefined && process.env.SENTRY_DSN) {\n    options.dsn = process.env.SENTRY_DSN;\n  }\n\n  if (options.tracesSampleRate === undefined && process.env.SENTRY_TRACES_SAMPLE_RATE) {\n    const tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);\n    if (isFinite(tracesSampleRate)) {\n      options.tracesSampleRate = tracesSampleRate;\n    }\n  }\n\n  if (options.release === undefined) {\n    const detectedRelease = getSentryRelease();\n    if (detectedRelease !== undefined) {\n      options.release = detectedRelease;\n    } else {\n      // If release is not provided, then we should disable autoSessionTracking\n      options.autoSessionTracking = false;\n    }\n  }\n\n  if (options.environment === undefined && process.env.SENTRY_ENVIRONMENT) {\n    options.environment = process.env.SENTRY_ENVIRONMENT;\n  }\n\n  if (options.autoSessionTracking === undefined && options.dsn !== undefined) {\n    options.autoSessionTracking = true;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n  if ((domain as any).active) {\n    setHubOnCarrier(carrier, getCurrentHub());\n  }\n\n  // TODO(v7): Refactor this to reduce the logic above\n  const clientOptions: NodeClientOptions = {\n    ...options,\n    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),\n    integrations: getIntegrationsToSetup(options),\n    transport: options.transport || makeNodeTransport,\n  };\n\n  initAndBind(NodeClient, clientOptions);\n\n  if (options.autoSessionTracking) {\n    startSessionTracking();\n  }\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n */\nexport function lastEventId(): string | undefined {\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<NodeClient>();\n  if (client) {\n    return client.flush(timeout);\n  }\n  __DEBUG_BUILD__ && logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<NodeClient>();\n  if (client) {\n    return client.close(timeout);\n  }\n  __DEBUG_BUILD__ && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Function that takes an instance of NodeClient and checks if autoSessionTracking option is enabled for that client\n */\nexport function isAutoSessionTrackingEnabled(client?: NodeClient): boolean {\n  if (client === undefined) {\n    return false;\n  }\n  const clientOptions = client && client.getOptions();\n  if (clientOptions && clientOptions.autoSessionTracking !== undefined) {\n    return clientOptions.autoSessionTracking;\n  }\n  return false;\n}\n\n/**\n * Returns a release dynamically from environment variables.\n */\nexport function getSentryRelease(fallback?: string): string | undefined {\n  // Always read first as Sentry takes this as precedence\n  if (process.env.SENTRY_RELEASE) {\n    return process.env.SENTRY_RELEASE;\n  }\n\n  // This supports the variable that sentry-webpack-plugin injects\n  const global = getGlobalObject();\n  if (global.SENTRY_RELEASE && global.SENTRY_RELEASE.id) {\n    return global.SENTRY_RELEASE.id;\n  }\n\n  return (\n    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables\n    process.env.GITHUB_SHA ||\n    // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata\n    process.env.COMMIT_REF ||\n    // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables\n    process.env.VERCEL_GIT_COMMIT_SHA ||\n    process.env.VERCEL_GITHUB_COMMIT_SHA ||\n    process.env.VERCEL_GITLAB_COMMIT_SHA ||\n    process.env.VERCEL_BITBUCKET_COMMIT_SHA ||\n    // Zeit (now known as Vercel)\n    process.env.ZEIT_GITHUB_COMMIT_SHA ||\n    process.env.ZEIT_GITLAB_COMMIT_SHA ||\n    process.env.ZEIT_BITBUCKET_COMMIT_SHA ||\n    fallback\n  );\n}\n\n/** Node.js stack parser */\nexport const defaultStackParser: StackParser = createStackParser(nodeStackLineParser(getModule));\n\n/**\n * Enable automatic Session Tracking for the node process.\n */\nfunction startSessionTracking(): void {\n  const hub = getCurrentHub();\n  hub.startSession();\n  // Emitted in the case of healthy sessions, error of `mechanism.handled: true` and unhandledrejections because\n  // The 'beforeExit' event is not emitted for conditions causing explicit termination,\n  // such as calling process.exit() or uncaught exceptions.\n  // Ref: https://nodejs.org/api/process.html#process_event_beforeexit\n  process.on('beforeExit', () => {\n    const session = hub.getScope()?.getSession();\n    const terminalStates: SessionStatus[] = ['exited', 'crashed'];\n    // Only call endSession, if the Session exists on Scope and SessionStatus is not a\n    // Terminal Status i.e. Exited or Crashed because\n    // \"When a session is moved away from ok it must not be updated anymore.\"\n    // Ref: https://develop.sentry.dev/sdk/sessions/\n    if (session && !terminalStates.includes(session.status)) hub.endSession();\n  });\n}\n\n/**\n * Add data from the given request to the given event\n *\n * (Note that there is no sister function to this one in `@sentry/browser`, because the whole point of this wrapper is\n * to pass along injected dependencies, which isn't necessary in a browser context. Isomorphic packages like\n * `@sentry/nextjs` should export directly from `@sentry/utils` in their browser index file.)\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @hidden\n */\nexport function addRequestDataToEvent(\n  event: Event,\n  req: CrossPlatformRequest,\n  options?: Omit<AddRequestDataToEventOptions, 'deps'>,\n): Event {\n  return _addRequestDataToEvent(event, req, {\n    ...options,\n    // We have to inject these node-only dependencies because we can't import them in `@sentry/utils`, where the\n    // original function lives\n    deps: { cookie, url },\n  });\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * (Note that there is no sister function to this one in `@sentry/browser`, because the whole point of this wrapper is\n * to inject dependencies, which isn't necessary in a browser context. Isomorphic packages like `@sentry/nextjs` should\n * export directly from `@sentry/utils` in their browser index file.)\n *\n * @param req The request object from which to extract data\n * @param options.keys An optional array of keys to include in the normalized data. Defaults to DEFAULT_REQUEST_KEYS if\n * not provided.\n * @returns An object containing normalized request data\n */\nexport function extractRequestData(\n  req: CrossPlatformRequest,\n  options?: {\n    include?: string[];\n  },\n): ExtractedNodeRequestData {\n  // We have to inject these node-only dependencies because we can't import them in `@sentry/utils`, where the original\n  // function lives\n  return _extractRequestData(req, { ...options, deps: { cookie, url } });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkHA;;AAEA;;;;;;;AAOA;;AAEA;;;;;;;;;;;;;;;AAeA;;AAEA;;;;;;;;;;;;;;;AAeA;;AAEA;;;;;;;;;;;;AAYA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;AAEA;;;AAGA;;;AAGA;;;;;;;;;;;;;;;;AAgBA;;AAEA;;;;;;;;;;;;;;;;AAgBA;;;;;;;AAOA;;AAEA;;;;;;;;;;;;;;;;AAgBA;AACA;;;;AAIA;;"}