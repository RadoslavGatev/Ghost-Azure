{"version":3,"file":"module.js","sources":["../../src/module.ts"],"sourcesContent":["import { basename, dirname } from '@sentry/utils';\n\n/** normalizes Windows paths */\nfunction normalizePath(path: string): string {\n  return path\n    .replace(/^[A-Z]:/, '') // remove Windows-style prefix\n    .replace(/\\\\/g, '/'); // replace all `\\` instances with `/`\n}\n\n/** Gets the module from a filename */\nexport function getModule(filename: string | undefined): string | undefined {\n  if (!filename) {\n    return;\n  }\n\n  const normalizedFilename = normalizePath(filename);\n\n  // We could use optional chaining here but webpack does like that mixed with require\n  const base = normalizePath(\n    `${(require && require.main && require.main.filename && dirname(require.main.filename)) || global.process.cwd()}/`,\n  );\n\n  // It's specifically a module\n  const file = basename(normalizedFilename, '.js');\n\n  const path = dirname(normalizedFilename);\n  let n = path.lastIndexOf('/node_modules/');\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return `${path.substr(n + 14).replace(/\\//g, '.')}:${file}`;\n  }\n  // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n  n = `${path}/`.lastIndexOf(base, 0);\n\n  if (n === 0) {\n    let moduleName = path.substr(base.length).replace(/\\//g, '.');\n    if (moduleName) {\n      moduleName += ':';\n    }\n    moduleName += file;\n    return moduleName;\n  }\n  return file;\n}\n"],"names":[],"mappings":";;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}