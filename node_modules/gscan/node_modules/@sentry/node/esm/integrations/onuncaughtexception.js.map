{"version":3,"file":"onuncaughtexception.js","sources":["../../../src/integrations/onuncaughtexception.ts"],"sourcesContent":["import type { Scope } from '@sentry/core';\nimport { getCurrentHub } from '@sentry/core';\nimport type { Integration } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport type { NodeClient } from '../client';\nimport { logAndExitProcess } from './utils/errorhandling';\n\ntype OnFatalErrorHandler = (firstError: Error, secondError?: Error) => void;\n\n// CAREFUL: Please think twice before updating the way _options looks because the Next.js SDK depends on it in `index.server.ts`\ninterface OnUncaughtExceptionOptions {\n  // TODO(v8): Evaluate whether we should switch the default behaviour here.\n  // Also, we can evaluate using https://nodejs.org/api/process.html#event-uncaughtexceptionmonitor per default, and\n  // falling back to current behaviour when that's not available.\n  /**\n   * Controls if the SDK should register a handler to exit the process on uncaught errors:\n   * - `true`: The SDK will exit the process on all uncaught errors.\n   * - `false`: The SDK will only exit the process when there are no other `uncaughtException` handlers attached.\n   *\n   * Default: `true`\n   */\n  exitEvenIfOtherHandlersAreRegistered: boolean;\n\n  /**\n   * This is called when an uncaught error would cause the process to exit.\n   *\n   * @param firstError Uncaught error causing the process to exit\n   * @param secondError Will be set if the handler was called multiple times. This can happen either because\n   * `onFatalError` itself threw, or because an independent error happened somewhere else while `onFatalError`\n   * was running.\n   */\n  onFatalError?(this: void, firstError: Error, secondError?: Error): void;\n}\n\n/** Global Exception handler */\nexport class OnUncaughtException implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'OnUncaughtException';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = OnUncaughtException.id;\n\n  /**\n   * @inheritDoc\n   */\n  public readonly handler: (error: Error) => void = this._makeErrorHandler();\n\n  // CAREFUL: Please think twice before updating the way _options looks because the Next.js SDK depends on it in `index.server.ts`\n  private readonly _options: OnUncaughtExceptionOptions;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: Partial<OnUncaughtExceptionOptions> = {}) {\n    this._options = {\n      exitEvenIfOtherHandlersAreRegistered: true,\n      ...options,\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    global.process.on('uncaughtException', this.handler);\n  }\n\n  /**\n   * @hidden\n   */\n  private _makeErrorHandler(): (error: Error) => void {\n    const timeout = 2000;\n    let caughtFirstError: boolean = false;\n    let caughtSecondError: boolean = false;\n    let calledFatalError: boolean = false;\n    let firstError: Error;\n\n    return (error: Error): void => {\n      let onFatalError: OnFatalErrorHandler = logAndExitProcess;\n      const client = getCurrentHub().getClient<NodeClient>();\n\n      if (this._options.onFatalError) {\n        onFatalError = this._options.onFatalError;\n      } else if (client && client.getOptions().onFatalError) {\n        onFatalError = client.getOptions().onFatalError as OnFatalErrorHandler;\n      }\n\n      // Attaching a listener to `uncaughtException` will prevent the node process from exiting. We generally do not\n      // want to alter this behaviour so we check for other listeners that users may have attached themselves and adjust\n      // exit behaviour of the SDK accordingly:\n      // - If other listeners are attached, do not exit.\n      // - If the only listener attached is ours, exit.\n      const userProvidedListenersCount = global.process\n        .listeners('uncaughtException')\n        .reduce<number>((acc, listener) => {\n          if (\n            listener.name === 'domainUncaughtExceptionClear' || // as soon as we're using domains this listener is attached by node itself\n            listener === this.handler // filter the handler we registered ourselves)\n          ) {\n            return acc;\n          } else {\n            return acc + 1;\n          }\n        }, 0);\n\n      const processWouldExit = userProvidedListenersCount === 0;\n      const shouldApplyFatalHandlingLogic = this._options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;\n\n      if (!caughtFirstError) {\n        const hub = getCurrentHub();\n\n        // this is the first uncaught error and the ultimate reason for shutting down\n        // we want to do absolutely everything possible to ensure it gets captured\n        // also we want to make sure we don't go recursion crazy if more errors happen after this one\n        firstError = error;\n        caughtFirstError = true;\n\n        if (hub.getIntegration(OnUncaughtException)) {\n          hub.withScope((scope: Scope) => {\n            scope.setLevel('fatal');\n            hub.captureException(error, {\n              originalException: error,\n              data: { mechanism: { handled: false, type: 'onuncaughtexception' } },\n            });\n            if (!calledFatalError && shouldApplyFatalHandlingLogic) {\n              calledFatalError = true;\n              onFatalError(error);\n            }\n          });\n        } else {\n          if (!calledFatalError && shouldApplyFatalHandlingLogic) {\n            calledFatalError = true;\n            onFatalError(error);\n          }\n        }\n      } else {\n        if (shouldApplyFatalHandlingLogic) {\n          if (calledFatalError) {\n            // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n            __DEBUG_BUILD__ &&\n              logger.warn(\n                'uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown',\n              );\n            logAndExitProcess(error);\n          } else if (!caughtSecondError) {\n            // two cases for how we can hit this branch:\n            //   - capturing of first error blew up and we just caught the exception from that\n            //     - quit trying to capture, proceed with shutdown\n            //   - a second independent error happened while waiting for first error to capture\n            //     - want to avoid causing premature shutdown before first error capture finishes\n            // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n            // so let's instead just delay a bit before we proceed with our action here\n            // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n            // in case 2, the delay hopefully made us wait long enough for the capture to finish\n            // two potential nonideal outcomes:\n            //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n            //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n            // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n            //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n            caughtSecondError = true;\n            setTimeout(() => {\n              if (!calledFatalError) {\n                // it was probably case 1, let's treat err as the sendErr and call onFatalError\n                calledFatalError = true;\n                onFatalError(firstError, error);\n              } else {\n                // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n              }\n            }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n          }\n        }\n      }\n    };\n  }\n}\n"],"names":[],"mappings":"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"}