{"version":3,"file":"envelope.js","sources":["../../src/envelope.ts"],"sourcesContent":["import type {\n  Attachment,\n  AttachmentItem,\n  BaseEnvelopeHeaders,\n  BaseEnvelopeItemHeaders,\n  DataCategory,\n  DsnComponents,\n  Envelope,\n  EnvelopeItem,\n  EnvelopeItemType,\n  Event,\n  EventEnvelopeHeaders,\n  SdkInfo,\n  SdkMetadata,\n  TextEncoderInternal,\n} from '@sentry/types';\n\nimport { dsnToString } from './dsn';\nimport { normalize } from './normalize';\nimport { dropUndefinedKeys } from './object';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function createEnvelope<E extends Envelope>(headers: E[0], items: E[1] = []): E {\n  return [headers, items] as E;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] as E;\n}\n\n/**\n * Convenience function to loop through the items and item types of an envelope.\n * (This function was mostly created because working with envelope types is painful at the moment)\n */\nexport function forEachEnvelopeItem<E extends Envelope>(\n  envelope: Envelope,\n  callback: (envelopeItem: E[1][number], envelopeItemType: E[1][number][0]['type']) => void,\n): void {\n  const envelopeItems = envelope[1];\n  envelopeItems.forEach((envelopeItem: EnvelopeItem) => {\n    const envelopeItemType = envelopeItem[0].type;\n    callback(envelopeItem, envelopeItemType);\n  });\n}\n\n/**\n * Encode a string to UTF8.\n */\nfunction encodeUTF8(input: string, textEncoder?: TextEncoderInternal): Uint8Array {\n  const utf8 = textEncoder || new TextEncoder();\n  return utf8.encode(input);\n}\n\n/**\n * Serializes an envelope.\n */\nexport function serializeEnvelope(envelope: Envelope, textEncoder?: TextEncoderInternal): string | Uint8Array {\n  const [envHeaders, items] = envelope;\n\n  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data\n  let parts: string | Uint8Array[] = JSON.stringify(envHeaders);\n\n  function append(next: string | Uint8Array): void {\n    if (typeof parts === 'string') {\n      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts, textEncoder), next];\n    } else {\n      parts.push(typeof next === 'string' ? encodeUTF8(next, textEncoder) : next);\n    }\n  }\n\n  for (const item of items) {\n    const [itemHeaders, payload] = item;\n\n    append(`\\n${JSON.stringify(itemHeaders)}\\n`);\n\n    if (typeof payload === 'string' || payload instanceof Uint8Array) {\n      append(payload);\n    } else {\n      let stringifiedPayload: string;\n      try {\n        stringifiedPayload = JSON.stringify(payload);\n      } catch (e) {\n        // In case, despite all our efforts to keep `payload` circular-dependency-free, `JSON.strinify()` still\n        // fails, we try again after normalizing it again with infinite normalization depth. This of course has a\n        // performance impact but in this case a performance hit is better than throwing.\n        stringifiedPayload = JSON.stringify(normalize(payload));\n      }\n      append(stringifiedPayload);\n    }\n  }\n\n  return typeof parts === 'string' ? parts : concatBuffers(parts);\n}\n\nfunction concatBuffers(buffers: Uint8Array[]): Uint8Array {\n  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);\n\n  const merged = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buffer of buffers) {\n    merged.set(buffer, offset);\n    offset += buffer.length;\n  }\n\n  return merged;\n}\n\nexport interface TextDecoderInternal {\n  decode(input?: Uint8Array): string;\n}\n\n/**\n * Parses an envelope\n */\nexport function parseEnvelope(\n  env: string | Uint8Array,\n  textEncoder: TextEncoderInternal,\n  textDecoder: TextDecoderInternal,\n): Envelope {\n  let buffer = typeof env === 'string' ? textEncoder.encode(env) : env;\n\n  function readBinary(length: number): Uint8Array {\n    const bin = buffer.subarray(0, length);\n    // Replace the buffer with the remaining data excluding trailing newline\n    buffer = buffer.subarray(length + 1);\n    return bin;\n  }\n\n  function readJson<T>(): T {\n    let i = buffer.indexOf(0xa);\n    // If we couldn't find a newline, we must have found the end of the buffer\n    if (i < 0) {\n      i = buffer.length;\n    }\n\n    return JSON.parse(textDecoder.decode(readBinary(i))) as T;\n  }\n\n  const envelopeHeader = readJson<BaseEnvelopeHeaders>();\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const items: [any, any][] = [];\n\n  while (buffer.length) {\n    const itemHeader = readJson<BaseEnvelopeItemHeaders>();\n    const binaryLength = typeof itemHeader.length === 'number' ? itemHeader.length : undefined;\n\n    items.push([itemHeader, binaryLength ? readBinary(binaryLength) : readJson()]);\n  }\n\n  return [envelopeHeader, items];\n}\n\n/**\n * Creates attachment envelope items\n */\nexport function createAttachmentEnvelopeItem(\n  attachment: Attachment,\n  textEncoder?: TextEncoderInternal,\n): AttachmentItem {\n  const buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data, textEncoder) : attachment.data;\n\n  return [\n    dropUndefinedKeys({\n      type: 'attachment',\n      length: buffer.length,\n      filename: attachment.filename,\n      content_type: attachment.contentType,\n      attachment_type: attachment.attachmentType,\n    }),\n    buffer,\n  ];\n}\n\nconst ITEM_TYPE_TO_DATA_CATEGORY_MAP: Record<EnvelopeItemType, DataCategory> = {\n  session: 'session',\n  sessions: 'session',\n  attachment: 'attachment',\n  transaction: 'transaction',\n  event: 'error',\n  client_report: 'internal',\n  user_report: 'default',\n  profile: 'profile',\n  replay_event: 'replay',\n  replay_recording: 'replay',\n};\n\n/**\n * Maps the type of an envelope item to a data category.\n */\nexport function envelopeItemTypeToDataCategory(type: EnvelopeItemType): DataCategory {\n  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n}\n\n/** Extracts the minimal SDK info from from the metadata or an events */\nexport function getSdkMetadataForEnvelopeHeader(metadataOrEvent?: SdkMetadata | Event): SdkInfo | undefined {\n  if (!metadataOrEvent || !metadataOrEvent.sdk) {\n    return;\n  }\n  const { name, version } = metadataOrEvent.sdk;\n  return { name, version };\n}\n\n/**\n * Creates event envelope headers, based on event, sdk info and tunnel\n * Note: This function was extracted from the core package to make it available in Replay\n */\nexport function createEventEnvelopeHeaders(\n  event: Event,\n  sdkInfo: SdkInfo | undefined,\n  tunnel: string | undefined,\n  dsn: DsnComponents,\n): EventEnvelopeHeaders {\n  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;\n\n  return {\n    event_id: event.event_id as string,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsnToString(dsn) }),\n    ...(event.type === 'transaction' &&\n      dynamicSamplingContext && {\n        trace: dropUndefinedKeys({ ...dynamicSamplingContext }),\n      }),\n  };\n}\n"],"names":["normalize","dropUndefinedKeys","dsn","dsnToString"],"mappings":";;;;;;AAqBA;AACA;AACA;AACA;AACA;AACA,SAAA,cAAA,CAAA,OAAA,EAAA,KAAA,GAAA,EAAA,EAAA;AACA,EAAA,OAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,iBAAA,CAAA,QAAA,EAAA,OAAA,EAAA;AACA,EAAA,MAAA,CAAA,OAAA,EAAA,KAAA,CAAA,GAAA,QAAA,CAAA;AACA,EAAA,OAAA,CAAA,OAAA,EAAA,CAAA,GAAA,KAAA,EAAA,OAAA,CAAA,CAAA,EAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,mBAAA;AACA,EAAA,QAAA;AACA,EAAA,QAAA;AACA,EAAA;AACA,EAAA,MAAA,aAAA,GAAA,QAAA,CAAA,CAAA,CAAA,CAAA;AACA,EAAA,aAAA,CAAA,OAAA,CAAA,CAAA,YAAA,KAAA;AACA,IAAA,MAAA,gBAAA,GAAA,YAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA;AACA,IAAA,QAAA,CAAA,YAAA,EAAA,gBAAA,CAAA,CAAA;AACA,GAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA,SAAA,UAAA,CAAA,KAAA,EAAA,WAAA,EAAA;AACA,EAAA,MAAA,IAAA,GAAA,WAAA,IAAA,IAAA,WAAA,EAAA,CAAA;AACA,EAAA,OAAA,IAAA,CAAA,MAAA,CAAA,KAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA,SAAA,iBAAA,CAAA,QAAA,EAAA,WAAA,EAAA;AACA,EAAA,MAAA,CAAA,UAAA,EAAA,KAAA,CAAA,GAAA,QAAA,CAAA;AACA;AACA;AACA,EAAA,IAAA,KAAA,GAAA,IAAA,CAAA,SAAA,CAAA,UAAA,CAAA,CAAA;AACA;AACA,EAAA,SAAA,MAAA,CAAA,IAAA,EAAA;AACA,IAAA,IAAA,OAAA,KAAA,KAAA,QAAA,EAAA;AACA,MAAA,KAAA,GAAA,OAAA,IAAA,KAAA,QAAA,GAAA,KAAA,GAAA,IAAA,GAAA,CAAA,UAAA,CAAA,KAAA,EAAA,WAAA,CAAA,EAAA,IAAA,CAAA,CAAA;AACA,KAAA,MAAA;AACA,MAAA,KAAA,CAAA,IAAA,CAAA,OAAA,IAAA,KAAA,QAAA,GAAA,UAAA,CAAA,IAAA,EAAA,WAAA,CAAA,GAAA,IAAA,CAAA,CAAA;AACA,KAAA;AACA,GAAA;AACA;AACA,EAAA,KAAA,MAAA,IAAA,IAAA,KAAA,EAAA;AACA,IAAA,MAAA,CAAA,WAAA,EAAA,OAAA,CAAA,GAAA,IAAA,CAAA;AACA;AACA,IAAA,MAAA,CAAA,CAAA,EAAA,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA;AACA;AACA,IAAA,IAAA,OAAA,OAAA,KAAA,QAAA,IAAA,OAAA,YAAA,UAAA,EAAA;AACA,MAAA,MAAA,CAAA,OAAA,CAAA,CAAA;AACA,KAAA,MAAA;AACA,MAAA,IAAA,kBAAA,CAAA;AACA,MAAA,IAAA;AACA,QAAA,kBAAA,GAAA,IAAA,CAAA,SAAA,CAAA,OAAA,CAAA,CAAA;AACA,OAAA,CAAA,OAAA,CAAA,EAAA;AACA;AACA;AACA;AACA,QAAA,kBAAA,GAAA,IAAA,CAAA,SAAA,CAAAA,mBAAA,CAAA,OAAA,CAAA,CAAA,CAAA;AACA,OAAA;AACA,MAAA,MAAA,CAAA,kBAAA,CAAA,CAAA;AACA,KAAA;AACA,GAAA;AACA;AACA,EAAA,OAAA,OAAA,KAAA,KAAA,QAAA,GAAA,KAAA,GAAA,aAAA,CAAA,KAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA,SAAA,aAAA,CAAA,OAAA,EAAA;AACA,EAAA,MAAA,WAAA,GAAA,OAAA,CAAA,MAAA,CAAA,CAAA,GAAA,EAAA,GAAA,KAAA,GAAA,GAAA,GAAA,CAAA,MAAA,EAAA,CAAA,CAAA,CAAA;AACA;AACA,EAAA,MAAA,MAAA,GAAA,IAAA,UAAA,CAAA,WAAA,CAAA,CAAA;AACA,EAAA,IAAA,MAAA,GAAA,CAAA,CAAA;AACA,EAAA,KAAA,MAAA,MAAA,IAAA,OAAA,EAAA;AACA,IAAA,MAAA,CAAA,GAAA,CAAA,MAAA,EAAA,MAAA,CAAA,CAAA;AACA,IAAA,MAAA,IAAA,MAAA,CAAA,MAAA,CAAA;AACA,GAAA;AACA;AACA,EAAA,OAAA,MAAA,CAAA;AACA,CAAA;;AAMA;AACA;AACA;AACA,SAAA,aAAA;AACA,EAAA,GAAA;AACA,EAAA,WAAA;AACA,EAAA,WAAA;AACA,EAAA;AACA,EAAA,IAAA,MAAA,GAAA,OAAA,GAAA,KAAA,QAAA,GAAA,WAAA,CAAA,MAAA,CAAA,GAAA,CAAA,GAAA,GAAA,CAAA;AACA;AACA,EAAA,SAAA,UAAA,CAAA,MAAA,EAAA;AACA,IAAA,MAAA,GAAA,GAAA,MAAA,CAAA,QAAA,CAAA,CAAA,EAAA,MAAA,CAAA,CAAA;AACA;AACA,IAAA,MAAA,GAAA,MAAA,CAAA,QAAA,CAAA,MAAA,GAAA,CAAA,CAAA,CAAA;AACA,IAAA,OAAA,GAAA,CAAA;AACA,GAAA;AACA;AACA,EAAA,SAAA,QAAA,GAAA;AACA,IAAA,IAAA,CAAA,GAAA,MAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA;AACA;AACA,IAAA,IAAA,CAAA,GAAA,CAAA,EAAA;AACA,MAAA,CAAA,GAAA,MAAA,CAAA,MAAA,CAAA;AACA,KAAA;AACA;AACA,IAAA,OAAA,IAAA,CAAA,KAAA,CAAA,WAAA,CAAA,MAAA,CAAA,UAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA;AACA,GAAA;AACA;AACA,EAAA,MAAA,cAAA,GAAA,QAAA,EAAA,CAAA;AACA;AACA,EAAA,MAAA,KAAA,GAAA,EAAA,CAAA;AACA;AACA,EAAA,OAAA,MAAA,CAAA,MAAA,EAAA;AACA,IAAA,MAAA,UAAA,GAAA,QAAA,EAAA,CAAA;AACA,IAAA,MAAA,YAAA,GAAA,OAAA,UAAA,CAAA,MAAA,KAAA,QAAA,GAAA,UAAA,CAAA,MAAA,GAAA,SAAA,CAAA;AACA;AACA,IAAA,KAAA,CAAA,IAAA,CAAA,CAAA,UAAA,EAAA,YAAA,GAAA,UAAA,CAAA,YAAA,CAAA,GAAA,QAAA,EAAA,CAAA,CAAA,CAAA;AACA,GAAA;AACA;AACA,EAAA,OAAA,CAAA,cAAA,EAAA,KAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA,SAAA,4BAAA;AACA,EAAA,UAAA;AACA,EAAA,WAAA;AACA,EAAA;AACA,EAAA,MAAA,MAAA,GAAA,OAAA,UAAA,CAAA,IAAA,KAAA,QAAA,GAAA,UAAA,CAAA,UAAA,CAAA,IAAA,EAAA,WAAA,CAAA,GAAA,UAAA,CAAA,IAAA,CAAA;AACA;AACA,EAAA,OAAA;AACA,IAAAC,wBAAA,CAAA;AACA,MAAA,IAAA,EAAA,YAAA;AACA,MAAA,MAAA,EAAA,MAAA,CAAA,MAAA;AACA,MAAA,QAAA,EAAA,UAAA,CAAA,QAAA;AACA,MAAA,YAAA,EAAA,UAAA,CAAA,WAAA;AACA,MAAA,eAAA,EAAA,UAAA,CAAA,cAAA;AACA,KAAA,CAAA;AACA,IAAA,MAAA;AACA,GAAA,CAAA;AACA,CAAA;AACA;AACA,MAAA,8BAAA,GAAA;AACA,EAAA,OAAA,EAAA,SAAA;AACA,EAAA,QAAA,EAAA,SAAA;AACA,EAAA,UAAA,EAAA,YAAA;AACA,EAAA,WAAA,EAAA,aAAA;AACA,EAAA,KAAA,EAAA,OAAA;AACA,EAAA,aAAA,EAAA,UAAA;AACA,EAAA,WAAA,EAAA,SAAA;AACA,EAAA,OAAA,EAAA,SAAA;AACA,EAAA,YAAA,EAAA,QAAA;AACA,EAAA,gBAAA,EAAA,QAAA;AACA,CAAA,CAAA;AACA;AACA;AACA;AACA;AACA,SAAA,8BAAA,CAAA,IAAA,EAAA;AACA,EAAA,OAAA,8BAAA,CAAA,IAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA;AACA,SAAA,+BAAA,CAAA,eAAA,EAAA;AACA,EAAA,IAAA,CAAA,eAAA,IAAA,CAAA,eAAA,CAAA,GAAA,EAAA;AACA,IAAA,OAAA;AACA,GAAA;AACA,EAAA,MAAA,EAAA,IAAA,EAAA,OAAA,EAAA,GAAA,eAAA,CAAA,GAAA,CAAA;AACA,EAAA,OAAA,EAAA,IAAA,EAAA,OAAA,EAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,0BAAA;AACA,EAAA,KAAA;AACA,EAAA,OAAA;AACA,EAAA,MAAA;AACA,EAAAC,KAAA;AACA,EAAA;AACA,EAAA,MAAA,sBAAA,GAAA,KAAA,CAAA,qBAAA,IAAA,KAAA,CAAA,qBAAA,CAAA,sBAAA,CAAA;AACA;AACA,EAAA,OAAA;AACA,IAAA,QAAA,EAAA,KAAA,CAAA,QAAA;AACA,IAAA,OAAA,EAAA,IAAA,IAAA,EAAA,CAAA,WAAA,EAAA;AACA,IAAA,IAAA,OAAA,IAAA,EAAA,GAAA,EAAA,OAAA,EAAA,CAAA;AACA,IAAA,IAAA,CAAA,CAAA,MAAA,IAAA,EAAA,GAAA,EAAAC,eAAA,CAAAD,KAAA,CAAA,EAAA,CAAA;AACA,IAAA,IAAA,KAAA,CAAA,IAAA,KAAA,aAAA;AACA,MAAA,sBAAA,IAAA;AACA,QAAA,KAAA,EAAAD,wBAAA,CAAA,EAAA,GAAA,sBAAA,EAAA,CAAA;AACA,OAAA,CAAA;AACA,GAAA,CAAA;AACA;;;;;;;;;;;;"}