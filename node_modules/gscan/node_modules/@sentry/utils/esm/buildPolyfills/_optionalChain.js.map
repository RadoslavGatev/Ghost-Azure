{"version":3,"file":"_optionalChain.js","sources":["../../../src/buildPolyfills/_optionalChain.ts"],"sourcesContent":["import type { GenericFunction } from './types';\n\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n * See https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nexport function _optionalChain(ops: unknown[]): unknown {\n  let lastAccessLHS: unknown = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i] as string;\n    const fn = ops[i + 1] as (intermediateValue: unknown) => unknown;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args: unknown[]) => (value as GenericFunction).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version\n// function _optionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n"],"names":[],"mappings":"AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,cAAA,CAAA,GAAA,EAAA;AACA,EAAA,IAAA,aAAA,GAAA,SAAA,CAAA;AACA,EAAA,IAAA,KAAA,GAAA,GAAA,CAAA,CAAA,CAAA,CAAA;AACA,EAAA,IAAA,CAAA,GAAA,CAAA,CAAA;AACA,EAAA,OAAA,CAAA,GAAA,GAAA,CAAA,MAAA,EAAA;AACA,IAAA,MAAA,EAAA,GAAA,GAAA,CAAA,CAAA,CAAA,EAAA;AACA,IAAA,MAAA,EAAA,GAAA,GAAA,CAAA,CAAA,GAAA,CAAA,CAAA,EAAA;AACA,IAAA,CAAA,IAAA,CAAA,CAAA;AACA;AACA,IAAA,IAAA,CAAA,EAAA,KAAA,gBAAA,IAAA,EAAA,KAAA,cAAA,KAAA,KAAA,IAAA,IAAA,EAAA;AACA;AACA,MAAA,OAAA;AACA,KAAA;AACA,IAAA,IAAA,EAAA,KAAA,QAAA,IAAA,EAAA,KAAA,gBAAA,EAAA;AACA,MAAA,aAAA,GAAA,KAAA,CAAA;AACA,MAAA,KAAA,GAAA,EAAA,CAAA,KAAA,CAAA,CAAA;AACA,KAAA,MAAA,IAAA,EAAA,KAAA,MAAA,IAAA,EAAA,KAAA,cAAA,EAAA;AACA,MAAA,KAAA,GAAA,EAAA,CAAA,CAAA,GAAA,IAAA,KAAA,CAAA,KAAA,GAAA,IAAA,CAAA,aAAA,EAAA,GAAA,IAAA,CAAA,CAAA,CAAA;AACA,MAAA,aAAA,GAAA,SAAA,CAAA;AACA,KAAA;AACA,GAAA;AACA,EAAA,OAAA,KAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}